---
title: Queue
date: 2023-01-05 00:40:00 +0800
categories: [Linear Structure]
tags: [Data Structure]
pin: true
author: Dragon

toc: true
comments: true

math: false
mermaid: true

typora-root-url: ./..
---
# [队列](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)

## 什么是队列

队列（QUeue）：具有一定操作约束的线性表——本质还是线性表
1.插入和删除操作：只在一端（front）做插入，而在另一端（rear）删除
2.插入数据：入队列（AddQ）
3.删除数据：出队列（DeleteQ）
4.后入先出：FIFO

## 队列的抽象数据类型描述
数据类型：队列（Queue）
数据对象集：一个有 0 个或多个元素的有穷线性表
操作集：长度为 MaxSize 的队列 Q ∈ Stack，队列元素 item ∈ ElementType

队列的基本操作主要有

```
Queue CreateQueue(int MaxSize)：生成长度为 MaxSize 的空队列
int IsFull(Queue Q)：判断队列 Q 是已满
void AddQ(Queue Q,ElementType item)：将数据元素 item 插入队列 Q 中
int IsEmpty(Queue Q)：判断队列 Q 是否为空
ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回
```

### 队列的顺序存储实现
队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front和尾元素rear组成，一般让他们一开始都为-1,即一开始都为空
使用队列这种线性结构时，仅使用n-1种元素,因为有n个元素，即有n+1种情况，front和rear之间的差距有n种，所以不能完全表述（particularly重合或空）

```c++
#include <bits/stdc++.h>
using namespace std;
#define MAXSIZE 100
typedef int ElementType;
typedef struct QNode *Queue;
struct QNode
{
    ElementType Data[MAXSIZE];
    int front; // 记录队头
    int rear;  // 记录队尾
};


Queue CreateQueue();                  // 初始化队列
int IsFull(Queue Q);                  // 判断队列是否已满
void AddQ(Queue Q, ElementType item); //  入队
ElementType DeleteQ(Queue Q);         // 出队
int IsEmpty(Queue Q);                 // 判断队列是否为空

// 1.创建队列
Queue CreateQueue()
{
    Queue Q = (Queue)malloc(sizeof(struct QNode));
    Q->front = -1;
    Q->rear = -1;
    return Q;
}

// 2. 判断队列是否已满
int IsFull(Queue Q)
{
    return ((Q->rear + 1) % MAXSIZE == Q->front);
}

// 3.入队列
void AddQ(Queue Q, ElementType item)
{
    if (IsFull)
    {
        cout << "队列满" << endl;
        return;
    }
    Q->rear = (Q->rear + 1) % MAXSIZE; // 因为是环形存储，所以要求余
    Q->Data[Q->rear] = item;
}

// 4.出队列
ElementType DeleteQ(Queue Q)
{
    if (IsFull)
    {
        cout << "队列空" << endl;
        return 0; // 0代表错误
    }else{
        Q->front = (Q->front + 1) % MAXSIZE;
        return Q->Data[Q->front];
    }
}
//5.判断队列是否为空
int IsEmpty(Queue Q)
{
    return (Q->front == Q->rear);
}

int main()
{
    return 0;
}
```

### 队列的链式存储实现

队列的链式存储结构也可以用一个单链表来实现。插入和删除操作分别在链表的两头进行
Question：队列指针front和rear应该分别指向链表的哪一头
A:删除在头，添加在链表尾部（不能倒置）
Q:Why?
A:因为如果在链表的尾端做删除操作，由于是单链表会丢失整个链表数据。而插入操作在表头表尾都相对方便，故选择表头删除，表尾插入，即表头front,表尾rear
```c++
#include <bits/stdc++.h>
using namespace std;

typedef int ElementType;
typedef struct QNode *Queue;
struct Node // 主干部分
{
    ElementType Data;
    struct Node *Next;
};
struct QNode
{
    struct Node *rear;  // 指向队尾结点
    struct Node *front; // 指向队头结点
};
Queue CreateQueue();                  // 初始化队列
void AddQ(Queue Q, ElementType item); //  入队
ElementType DeleteQ(Queue Q);         // 出队
int IsEmpty(Queue Q);                 // 判断队列是否为空
```
由于该表述比较抽象，所以我附加上图片便于理解
![解释](C:\Users\86151\Documents\GitHub\Dragon622.github.io\assets\blog_res\duilie.png)

```c++
// 初始化
Queue CreateQueue()
{
    Queue Q;
    Q = (Queue)malloc(sizeof(struct QNode));
    Q->front = NULL;
    Q->rear = NULL;
    return Q;
}
// 判断队列是否空
int IsEmpty(Queue Q)
{
    return (Q->front == NULL);
}
// 不带头结点的链式队列出队操作
ElementType DeleteQ(Queue Q)
{
    struct Node *FrontCell;
    ElementType FrontItem;
    if (IsEmpty)
    {
        cout << "队列空" << endl;
        return 0;
    }
    FrontCell = Q->front;    // 用于返回队列顶元素
    if (Q->front == Q->rear) // 若队列只有一个元素
        Q->front == Q->rear == NULL;
    else
        Q->front = Q->front->Next;
    // 无论是第二个if还是else都需要要执行下列操作
    FrontItem = FrontCell->Data;
    free(FrontCell);
    return FrontItem; // 返回队列首元素
}
// 入队操作,每次入队就是插入一个struct Node类型的一个结构
void AddQ(Queue Q, ElementType item)
{
    struct Node *node = (struct Node *)malloc(sizeof(struct Node));
    node->Data = item;
    node->Next = NULL;
    if (IsEmpty)
    {
        Q->front = node;
        Q->rear = node;
    }
    else // 不为空
    {
        Q->rear->Next = node; // 把新结点接在原队列后面
        Q->rear = node;       // rear始终指向队列尾端
    }
}

int main()
{
    return 0;
}
```