[ { "title": "The Definition Of The Tree", "url": "/posts/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/", "categories": "Tree", "tags": "Data Structure", "date": "2023-01-07 16:07:00 +0000", "snippet": "1.树的定义树（Tree）：n（n≥0）个结点构成的有限集合当 n=0 时，称为空树1.特征对于任一棵非空树（n＞0），它具备以下特征：1)树中有个称为“根（Root）”的特殊结点，用 r 表示2)其余结点可分为 m(m&gt;0) 个互不相交的有限集 $T _1$ $T _2$…$T _m$3)子树是不相交的(数是非连通图)4)除根结点外，每个结点有且仅有一个父结点(可以用族谱来理解，最上...", "content": "1.树的定义树（Tree）：n（n≥0）个结点构成的有限集合当 n=0 时，称为空树1.特征对于任一棵非空树（n＞0），它具备以下特征：1)树中有个称为“根（Root）”的特殊结点，用 r 表示2)其余结点可分为 m(m&gt;0) 个互不相交的有限集 $T _1$ $T _2$…$T _m$3)子树是不相交的(数是非连通图)4)除根结点外，每个结点有且仅有一个父结点(可以用族谱来理解，最上面的没有…，其他的有且仅有一个😄)5)一棵 N 个结点的树有 N-1 条边(可以理解成除了根结点每个点都有一条向上的边)2. 基本术语1)结点的度（Degree）：结点的子树个数(每个点有几个儿子)2)树的度：树的所有结点中最大的度数3)叶结点（Leaf）：度为 0 的结点4)父结点（Parent）：有子树的结点是其子树的根结点叫父结点5)子结点（Child）：若 A 结点是 B 结点的父结点，则称 B 结点是 A 结点的子结点，也称孩子结点6)兄弟结点（Sibling）：具有同一父结点的各个结点彼此是兄弟结点7)路径：从结点$n _1$到$n _k$的路径为一个结点序列$n _1$$n _2$…$n _k$，其中$n _i$是$n _{i+1}$的父结点8)路径长度：路径所包含边的个数9)子孙结点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙10)结点的层次（Level）：规定根结点在 1 层，其他任一结点的层数是其父结点的层数加一11)树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度(这个结点一定是叶结点)3.数的表示1.儿子-兄弟表示法• Element 存值• FirstChild 指向第一个儿子• NextSibling 指向下一个兄弟2.二叉树即度为 2 的树二叉树其实就是儿子-兄弟表示法的链表右移 45° 得到的结果2.二叉树1.定义1.二叉树 T：一个有穷的结点集合2.​这个集合可以为空3.若不为空，则它是由根结点和称为其左子树$T _L$ 和右子树$T _R$的两个不相交的二叉树组成4.二叉树的子树有左右顺序之分2.五种基本形态3.特殊形态·斜二叉树(只有左儿子或只有右儿子)·完美二叉树(满二叉树)除最后一层叶节点外，每个节点都有两个子结点·完全二叉树(不是那么完美的完美二叉树😄)有 n 个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号，编号为 i（1≤i≤n）结点与满二叉树中编号为 i 结点在二叉树中位置相同4.重要性质·一个二叉树第i层的最大结点数为：$2^{i-1}$·深度为k的二叉树有最大节点总数为$s^k-1$·对任何非空二叉树T，若$n_0$表示叶结点的个数，$n_2$表示度为2的结点的个数，那么两者的关系是$n_0$=$n_2$+1下面我证明一下：咱们以边的总数来列一个等式，该二叉树一共有（$n_0$+$n_1$+$n_2$）个点，所以有（$n_0$+$n_1$+$n_2$）-1条边，而不同种结点对边的总数的贡献为$n_0$贡献0条边，$n_1$贡献一条边，$n_2$贡献两条边所以可以列出$n_0$+$n_1$+$n_2$-1 = $n_0$0+$n_1$1+$n_2$*2最后可以得出$n_0$=$n_2$+15.抽象数据类型定义·类型名称：二叉树·数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成·操作集：BT ∈ BinTree，Item ∈ ElementType主要操作有Boolean IsEmpty(BinTree BT)：判别 BT 是否为空void Traversal(BinTree BT)：遍历，按某顺序访问每个结点//最重要啦！！！！BinTree CreatBinTree()：创建一个二叉树常见的遍历方法有void PreOrderTraversal(BinTree BT)：先序——根、左子树、右子树void InOrderTraversal(BinTree BT)：中序——左子树、根、右子树void PostOrderTraversal(BinTree BT)：后序——左子树、右子树、根void LevelOrderTraversal(BinTree BT)：层次遍历，从上到下、从左到右1.顺序存储结构(建立前提为完全二叉树，不完全要假装补全，并像完全二叉树那样标号，主要是标号操作)按从上至下、从左到右顺序存储 n 个结点的完全二叉树的结点父子关系：·非根结点（序号 i &gt; 1）的父结点的序号是 ⌊i/2⌋（向下取整）·结点（序号为 i）的左孩子结点的序号是 2i(成立条件：2i ≤n，否则没有左孩子)·结点（序号为 i）的右孩子结点的序号是 2i+1(成立条件：2i+1 ≤ n，否则没有右孩子)2.链表存储下面给出结构体typedef struct TreeNode *BinTree;struct TreeNode{\tElement Data; // 存值 \tBinTree Left; // 左儿子结点 \tBinTree Right; // 右儿子结点 };//下面讲详细展开二叉树的便利，所以独立出来喽" }, { "title": "Queue", "url": "/posts/%E9%98%9F%E5%88%97/", "categories": "Linear Structure", "tags": "Data Structure", "date": "2023-01-04 16:40:00 +0000", "snippet": "队列什么是队列队列（QUeue）：具有一定操作约束的线性表——本质还是线性表1.插入和删除操作：只在一端（front）做插入，而在另一端（rear）删除2.插入数据：入队列（AddQ）3.删除数据：出队列（DeleteQ）4.后入先出：FIFO队列的抽象数据类型描述数据类型：队列（Queue）数据对象集：一个有 0 个或多个元素的有穷线性表操作集：长度为 MaxSize 的队列 Q ∈ St...", "content": "队列什么是队列队列（QUeue）：具有一定操作约束的线性表——本质还是线性表1.插入和删除操作：只在一端（front）做插入，而在另一端（rear）删除2.插入数据：入队列（AddQ）3.删除数据：出队列（DeleteQ）4.后入先出：FIFO队列的抽象数据类型描述数据类型：队列（Queue）数据对象集：一个有 0 个或多个元素的有穷线性表操作集：长度为 MaxSize 的队列 Q ∈ Stack，队列元素 item ∈ ElementType队列的基本操作主要有Queue CreateQueue(int MaxSize)：生成长度为 MaxSize 的空队列int IsFull(Queue Q)：判断队列 Q 是已满void AddQ(Queue Q,ElementType item)：将数据元素 item 插入队列 Q 中int IsEmpty(Queue Q)：判断队列 Q 是否为空ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回队列的顺序存储实现队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front和尾元素rear组成，一般让他们一开始都为-1,即一开始都为空使用队列这种线性结构时，仅使用n-1种元素,因为有n个元素，即有n+1种情况，front和rear之间的差距有n种，所以不能完全表述（particularly重合或空）队列是环形存储，以便于不断插入和删除#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ElementType;typedef struct SNode *Stack;typedef int ElementType; // ElementType 暂时定义为 int 类型struct SNode{ ElementType Data; Stack Next;};// Top应该在链表的左端（头部）进行，原因是方便push和pop，若是在尾端push是方便的，pop不方便，因为是单向链表Stack CreateStack(); // 初始化链栈int IsEmpty(Stack S); // 判断链栈是否为空void Push(Stack S, ElementType item); // 入栈ElementType Pop(Stack S); // 出栈Stack CreateStack() // 建立一个堆栈的头结点并返回指针{ Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;}int IsEmpty(Stack S){ return (S-&gt;Next == NULL); // 逻辑运算 // 判断堆栈S是否为空，若为空则返回整数1，否则返回0}void Push(ElementType item, Stack S){ // 将元素item压入堆栈S Stack TmpCell = (Stack)malloc(sizeof(struct SNode)); TmpCell-&gt;Data = item; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell;}//删除并返回堆栈S的栈顶元素ElementType Pop(Stack S){ Stack FirstCell; ElementType TopVal; if (IsEmpty(S)) { cout &lt;&lt; \"堆栈空\" &lt;&lt; endl; return NULL; } else { FirstCell = S-&gt;Next; S-&gt;Next = FirstCell-&gt;Next; TopVal = S-&gt;Data; free(FirstCell); return TopVal; }}int main(){ return 0;}队列的链式存储实现队列的链式存储结构也可以用一个单链表来实现。插入和删除操作分别在链表的两头进行Q：队列指针front和rear应该分别指向链表的哪一头A：删除在头，添加在链表尾部（不能倒置）Q:why?A:如果队列的删除操作如果在链表尾进行，由于是单向链表，所以在链表尾删除后会丢失整个链表，而插入操作在链表头或者链表尾都比较好操作#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ElementType;typedef struct QNode *Queue;struct Node // 主干部分{ ElementType Data; struct Node *Next;};struct QNode{ struct Node *rear; // 指向队尾结点 struct Node *front; // 指向队头结点};Queue CreateQueue(); // 初始化队列void AddQ(Queue Q, ElementType item); // 入队ElementType DeleteQ(Queue Q); // 出队int IsEmpty(Queue Q); // 判断队列是否为空由于此处有两种结构，比较抽象,给出图片以助于理解结构体Node为队列的主干结构，可以有若干个结构体QNode在表头存在，只有一个，用于存储front和rear// 初始化Queue CreateQueue(){ Queue Q; Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;front = NULL; Q-&gt;rear = NULL; return Q;}// 判断队列是否空int IsEmpty(Queue Q){ return (Q-&gt;front == NULL);}// 不带头结点的链式队列出队操作ElementType DeleteQ(Queue Q){ struct Node *FrontCell; ElementType FrontItem; if (IsEmpty) { cout &lt;&lt; \"队列空\" &lt;&lt; endl; return 0; } FrontCell = Q-&gt;front; // 用于返回队列顶元素 if (Q-&gt;front == Q-&gt;rear) // 若队列只有一个元素 Q-&gt;front == Q-&gt;rear == NULL; else Q-&gt;front = Q-&gt;front-&gt;Next; // 无论是第二个if还是else都需要要执行下列操作 FrontItem = FrontCell-&gt;Data; free(FrontCell); return FrontItem; // 返回队列首元素}// 入队操作,每次入队就是插入一个struct Node类型的一个结构void AddQ(Queue Q, ElementType item){ struct Node *node = (struct Node *)malloc(sizeof(struct Node)); node-&gt;Data = item; node-&gt;Next = NULL; if (IsEmpty) { Q-&gt;front = node; Q-&gt;rear = node; } else // 不为空 { Q-&gt;rear-&gt;Next = node; // 把新结点接在原队列后面 Q-&gt;rear = node; // rear始终指向队列尾端 }}int main(){ return 0;}" }, { "title": "stack", "url": "/posts/%E5%A0%86%E6%A0%88/", "categories": "Linear Structure", "tags": "Data Structure", "date": "2023-01-04 16:40:00 +0000", "snippet": "堆栈什么是堆栈堆栈（stack）：具有一定操作约束的线性表——本质还是线性表1.只在一端（栈顶，Top）做插入、删除2.插入数据：入栈（Push）3.删除数据：出栈（Pop）4.后入先出：Last In First Out（LIFO）堆栈的抽象数据类型描述数据类型：堆栈（stack）数据对象集：一个有 0 个或多个元素的有穷线性表操作集：长度为 MaxSize 的堆栈 S ∈ Stack，堆...", "content": "堆栈什么是堆栈堆栈（stack）：具有一定操作约束的线性表——本质还是线性表1.只在一端（栈顶，Top）做插入、删除2.插入数据：入栈（Push）3.删除数据：出栈（Pop）4.后入先出：Last In First Out（LIFO）堆栈的抽象数据类型描述数据类型：堆栈（stack）数据对象集：一个有 0 个或多个元素的有穷线性表操作集：长度为 MaxSize 的堆栈 S ∈ Stack，堆栈元素 item ∈ ElementType堆栈的基本操作主要有Stack CreateStack(int Maxsize):生成空堆栈，其最大长度为MaxSizeint IsFull(Stack S,int MaxSize)：判断堆栈 S 是否已满void Push(Stack S,ElementType item)：将元素 item 压入堆栈int IsEmpty(Stack S)：判断堆栈 S 是否为空ElementType Pop(Stack S)：删除并返回栈顶元素堆栈的顺序存储实现栈的顺序存储实现通常由一个一维数组和一个记录栈顶元素位置的变量组成（非常非常类似于线性表的顺序存储结构）#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100 // 堆栈元素的最大个数typedef int ElementType; // ElementType 暂时定义为 int 类型typedef struct SNode *Stack;struct SNode{ ElementType Data[MAXSIZE]; // 存储堆栈元素 int Top; // 记录栈顶元素下标};// Top=-1代表堆栈空，Top=MAXSIZE-1表示栈堆满，top的值就是数组的下标Stack S;// 函数汇总Stack CreateStack(); // 初始化堆栈int IsFull(Stack S); // 判断堆栈是否已满int IsEmpty(Stack S); // 判断堆栈是否为空void Push(Stack S, ElementType item); // 入栈ElementType Pop(Stack S); // 出栈Stack CreateStack(){ S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Top = -1; return S;}// 是否已满int IsFull(Stack S){ return (S-&gt;Top == MAXSIZE - 1);}// 是否为空int IsEmpty(Stack S){ return (S-&gt;Top == -1);}// 入栈void Push(Stack S, ElementType item){ if (S-&gt;Top + 1 == MAXSIZE) { cout &lt;&lt; \"堆栈满\" &lt;&lt; endl; return; } else { S-&gt;Data[++(S-&gt;Top)] = item; return; }}// 出栈ElementType Pop(Stack S){ if (S-&gt;Top == -1) { cout &lt;&lt; \"堆栈空\" &lt;&lt; endl; return 0; } else return (S-&gt;Data[(S-&gt;Top)--]);}int main(){ return 0;}堆栈的链式存储实现再次强化思想，堆栈就是操作受约束的线性表！！！！！！！！栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ElementType;typedef struct SNode *Stack;typedef int ElementType; // ElementType 暂时定义为 int 类型struct SNode{ ElementType Data; Stack Next;};// Top应该在链表的左端（头部）进行，原因是方便push和pop，若是在尾端push是方便的，pop不方便，因为是单向链表Stack CreateStack(); // 初始化链栈int IsEmpty(Stack S); // 判断链栈是否为空void Push(Stack S, ElementType item); // 入栈ElementType Pop(Stack S); // 出栈Stack CreateStack() // 建立一个堆栈的头结点并返回指针{ Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;}int IsEmpty(Stack S){ return (S-&gt;Next == NULL); // 逻辑运算 // 判断堆栈S是否为空，若为空则返回整数1，否则返回0}void Push(ElementType item, Stack S){ // 将元素item压入堆栈S Stack TmpCell = (Stack)malloc(sizeof(struct SNode)); TmpCell-&gt;Data = item; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell;}//删除并返回堆栈S的栈顶元素ElementType Pop(Stack S){ Stack FirstCell; ElementType TopVal; if (IsEmpty(S)) { cout &lt;&lt; \"堆栈空\" &lt;&lt; endl; return NULL; } else { FirstCell = S-&gt;Next; S-&gt;Next = FirstCell-&gt;Next; TopVal = S-&gt;Data; free(FirstCell); return TopVal; }}int main(){ return 0;}" }, { "title": "List", "url": "/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/", "categories": "Linear Structure", "tags": "Data Structure", "date": "2023-01-04 15:00:00 +0000", "snippet": "线性表(维基百科)1.什么是线性表线性表：由同种类型数据元素构成的线性结构：1.表中元素个数称为线性表的长度2.线性表中没有元素时，称为空表3.表的起始位置称为表头，表的结束位置称为表尾//我认为线性表是最重要的线性结构，因为其他线性结构都是在线性表的基础上来实现的，掌握好线性表的相关操作，别的线性结构就hi很简单啦！！2.线性表的抽象数据结构类型描述1.类型名称：线性表（List）2.数据...", "content": "线性表(维基百科)1.什么是线性表线性表：由同种类型数据元素构成的线性结构：1.表中元素个数称为线性表的长度2.线性表中没有元素时，称为空表3.表的起始位置称为表头，表的结束位置称为表尾//我认为线性表是最重要的线性结构，因为其他线性结构都是在线性表的基础上来实现的，掌握好线性表的相关操作，别的线性结构就hi很简单啦！！2.线性表的抽象数据结构类型描述1.类型名称：线性表（List）2.数据对象集：线性表是 n (≥0) 个元素构成的有序序列($a_1$,$a_2$,…,$a_n$)3.操作集：线性表L∈List，整数i表示位置，元素X∈ElementType线性表的基本操作有List MakeEmpty():初始化一个空线性表ElementType FindKth(int k,List L):根据序列k，返回相应元素int Find(ElementType X,List L)：在线性表L中查找X的第一次出现位置void Delete(int i,List L):删除指定序列i的元素int Length(List L):返回线性表L的长度n1.线性表的顺序存储实现利用数组的连续存储空间顺序存放线性表的个元素注：顺序存储中的序号是下标，从0开始#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100typedef int ElementType; // ElementType 暂时定义为 int 类型typedef struct LNode *List;struct LNode{ ElementType Data[MAXSIZE]; int Last; // 用于访问长度};List PtrL;// 访问下标为1的元素：L.Data[i]或PtrL-&gt;Data[i]// 线性表的长度：L.Last+1或PtrL-&gt;Last+1// 访问最大角标是最大长度减一，so最大下角标是PtrL-&gt;Last// 线性表的顺式存储实现// 1.建立空表，不需要参数List MakeEmpty(){ List PtrL; PtrL = (List)malloc(sizeof(struct LNode)); PtrL-&gt;Last = -1; // 没有元素就是负一，因为需要用PtrL-&gt;Last+1来表示线性表的长度 return PtrL;}// 2.查找有没有X元素，并返回X的位置// 按序查找int Find(ElementType X, List PtrL) // ElementType X被找的，List PtrL传进来的结构体指针，用于访问整个结构{ int i = 0; while (i &lt; PtrL-&gt;Last + 1 &amp;&amp; PtrL-&gt;Data[i] != X) // PtrL-&gt;Data[i] == X的时候说明找到了，否则就不断的走 i++; // 退出循环有两种可能1.找到了，2越界了 if (i &gt;= PtrL-&gt;Last + 1) return -1; else return i; // 找到后返回的是存储位置} // 平均次数（n+1）/2，时间复杂度O（n）// 3.插入（第i(1≤i≤n+1) 个位置插入一个值为X的新元素）void Insert(ElementType X, int i, List PtrL)// 注意第i个位置的下角标是i-1// 先移动再插入，先把第n个元素-&gt;n+1，再将第i个元素之后的元素以此向后{ int j; if (PtrL-&gt;Last + 1 == MAXSIZE) { cout &lt;&lt; \"表满\" &lt;&lt; endl; return; } if (i &lt; 1 || i &gt; PtrL-&gt;Last + 2) { cout &lt;&lt; \"位置不合法\" &lt;&lt; endl; return; } for (j = PtrL-&gt;Last; j &gt;= i - 1; j--) // j=i-1的时候退出循环 PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; // 将ai~an倒序向后移动 PtrL-&gt;Data[i - 1] = X; // 新元素插入 PtrL-&gt;Last++; // 最大长度加一 return; // 可以去掉} // 平均次数（n+1）/2，时间复杂度O（n）// 4.删除（删除表第i(1≤i≤n)个位置上的元素） **1≤i≤n对应数组下标0~n-1// 删除第i个元素，将后面的元素依次向前移动，i-&gt;i-1...按照从左往右void Delete(int i, List PtrL){ int j; if (i &lt; 1 || i &gt; PtrL-&gt;Last + 1) //检查空表及删除位置的合法性 { printf(\"不存在第%d个元素\", i); return; } for (j = i; j &lt;= PtrL-&gt;Last;j++) PtrL-&gt;Data[j - 1] = PtrL-&gt;Data[j]; // 将aj+1~an顺序向前移动 PtrL-&gt;Last--; //List仍指向最后元素} // 平均次数（n+1）/2，时间复杂度O（n）// 表长int Length(List L){ return L-&gt;Last + 1;}int main(){ return 0;}2.线性表的链式存储实现不要求逻辑上相邻的两个元素物理也相邻；通过“链”建立起数据元素之间的数据逻辑插入删除不需要移动数据元素，只需要修“改链”#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100typedef int ElementType; // ElementType 暂时定义为 int 类型typedef struct LNode *List;struct LNode{ ElementType Data; List Next; // 用于访问长度};struct LNode L;List PtrL;// 1.求表长int Length(List PtrL){ List p = PtrL; int idx = 0; // 计数器用于记长度 while (p) { p = p-&gt;Next; idx++; } return idx;} // 时间性能O(n)// 2.查找// （1）按序号查找：FindKthList FindKth(int K, List PtrL){ List p = PtrL; int i = 1; // 一开始p指向了第一个元素 while (p != NULL &amp;&amp; i &lt; K) { p = p-&gt;Next; i++; } if (i == K) return p; // 找到第K个，返回指针 else return NULL; // 否则返回空} // 时间性能O(n)// （2）按值查找List Find(ElementType X, List PtrL){ List p = PtrL; while (p != NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; return p;} // 时间性能O(n)// 3.插入（在第i-1(1≤i≤n+1)个结点后插入一个值为X的新结点）// （1）构造一个新的结点，用s指向；// （2）再找到链表的第i-1个结点，用p指向；// （3）然后修改指针，插入结点（p之后的新结点时s）List Insert(ElementType X, int i, List PtrL){ List p, s; if (i == 1) // 新结点插入表头 { s = (List)malloc(sizeof(struct LNode)); // 申请并且填装结点 s-&gt;Data = X; s-&gt;Next = PtrL; return s; // 返回新结点指针 } p = FindKth(i - 1, PtrL); if (p == NULL) { cout &lt;&lt; \"参数错误\" &lt;&lt; endl; return NULL; } else { s = (List)malloc(sizeof(struct LNode)); // 申请并且填装 s-&gt;Data = X; s-&gt;Next = p-&gt;Next; // 新结点插入在第i-1个结点的后面 p-&gt;Next = s; return PtrL; }}// 4.删除（删除链表的第i（1≤i≤n）个位置上的结点）；// （1）先找到链表的第i-1个结点，用p指向；// （2）再用指针s指向被删除的结点（p的下一个结点）；// （3）然后修改指针，删除s所指向的结点// （4）最后释放s所指结点的空间 free（s）List Delete(int i, List PtrL){ List p, s; if (i == 1) { s = PtrL; if (PtrL) PtrL = PtrL-&gt;Next; else return NULL; free(s); return PtrL; } p = FindKth(i - 1, PtrL); if (p == NULL) { printf(\"第%d个节点不存在\", i - 1); return NULL; } else if (p-&gt;Next == NULL) { printf(\"第%d个节点不存在\", i); return NULL; } else { s = p-&gt;Next; p-&gt;Next = s-&gt;Next; free(s); return PtrL; }}// 时间性能O(n)int main(){ return 0;}作为最基础的线性结构，也是最重要的结构，我们一定要熟练掌握，争取自己能写出来，不要求一字不差的将模板默写出来，要根据自己的理解来实现出来，再完成课后习题作业" }, { "title": "Basic Concepts Of Data Structures's Exercises", "url": "/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%A0%E9%A2%98/", "categories": "Linear Structure", "tags": "Linear Structure Exercises", "date": "2023-01-03 08:17:00 +0000", "snippet": "#数据结构基本概念本章课程比较简单而且比较抽象…主要是比较抽象，我就直接写课后题不写知识点了…….题目1单链表逆转本道题为函数体，我直接给出函数接口List Reversr (List L){ List p,temp; P-&gt;Next =NULL;//给p的指针域赋空作为链表尾部 while(L){ L-&gt;Next=temp;//先处理第一个结点，...", "content": "#数据结构基本概念本章课程比较简单而且比较抽象…主要是比较抽象，我就直接写课后题不写知识点了…….题目1单链表逆转本道题为函数体，我直接给出函数接口List Reversr (List L){ List p,temp; P-&gt;Next =NULL;//给p的指针域赋空作为链表尾部 while(L){ L-&gt;Next=temp;//先处理第一个结点，就先把后面的结点都先存下来 L-&gt;Next=p;//将第一个结点指向p p=L;//再将p指针变成头部 L=temp;//把预先保留的链表剩余部分赋回去 } return p;//进行完循环，p仍是指针头部，返回p即可}做链表题的时候可以通过画图来分析，图画出来，问题迎刃而解!!下面给出我的图解（画的不好看凑合看😅）题目二一元多项式的乘法与加法运算" }, { "title": "Basic Concepts Of Data Structures's Exercises", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/", "categories": "Basic Concepts Of Data Structures", "tags": "Data Structure Exercises", "date": "2023-01-03 08:17:00 +0000", "snippet": "#数据结构基本概念本章课程比较简单而且比较抽象…主要是比较抽象，我就直接写课后题不写知识点了…….题目1最大子列和问题陈越老师上课给出了四种方法，其中分治算法情况没有给出代码，下文中我已经补全。先给出主函数int main(){ int n; int a[100000 + 5]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i+...", "content": "#数据结构基本概念本章课程比较简单而且比较抽象…主要是比较抽象，我就直接写课后题不写知识点了…….题目1最大子列和问题陈越老师上课给出了四种方法，其中分治算法情况没有给出代码，下文中我已经补全。先给出主函数int main(){ int n; int a[100000 + 5]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; auto res = MaxSubseqSum1(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum2(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum3(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum4(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum5(n, a); cout &lt;&lt; res &lt;&lt; endl; return 0;}算法一最直接也是最直观的想法，一个循环控制子列的尾部，内嵌一个循环控制子列的头部，再内嵌一个循环来求解首部到尾部间子列和，每次求解完和更新最大值。int MaxSubseqSum1(int n, int *a){ int ThisSum, max = 0; int i, j, k; for (i = 0; i &lt; n; i++) // i是子列左端 { for (j = i; j &lt; n; j++) // j是子列右端 { ThisSum = 0; // ThisSum是从a[i]到a[j]的和 for (k = i; k &lt;= j; k++) ThisSum += a[k]; if (ThisSum &gt; max) max = ThisSum; // 如果大，就更新子列 } // j循环结束 } // i循环结束 return max;}最好理解，时间复杂度也最大T(N)=O(N^3)算法二考虑优化算法一，观察发现每次计算之后的子列和前面的子列都需要重新计算（比如计算 Sum(n+1)需要重新计算 Sum(n)），那我们可以这样优化，想办法能不能将每次计算的结果保存一下，即一个循环控制子列的首部，内嵌一个循环，既控制子列的尾部，也表示该段子列和，叠加一次更新一次最大值。int MaxSubseqSum2(int n, int *a){ int ThisSum, max = 0; int i, j; for (i = 0; i &lt; n; i++) // i是子列左端 { ThisSum = 0; // ThisSum是从a[i]到a[j]的和 for (j = i; j &lt;= n; j++) // j是子列右端 { ThisSum += a[j]; // 对于相同的i不同的j，主要在j-1次循环的基础上累加1项即可 if (ThisSum &gt; max) max = ThisSum; // 如果大，就更新子列 } // j循环结束 } // i循环结束 return max;} // 把之前控制尾部的循环和求解子列和的循环融合了，T(N)=O(N^2)算法三算法三和算法二类似，不过算法二是控制首部，逐渐累加，算法三是控制尾部，逐渐减值。从首部出发可以自然的用一个数保存整段子列和，而从尾部出发则需要额外数组空间来保存子列和，额外数组空间首先保存其前 n 个数之和，然后每次减去当前值形成子列和。int MaxSubseqSum3(int n, int a[]) // 方法三：确定子列的结尾，逐个减去子列前的数，时间复杂度 O(n^2){ int sum[100000 + 5]; int max = 0; sum[0] = a[0]; for (int i = 1; i &lt; n; i++) // 预处理保存前 n 个数之和 sum[i] = sum[i - 1] + a[i]; for (int i = 0; i &lt; n; i++) // 控制尾部 { int tmpSum = sum[i]; for (int j = 0; j &lt;= i; j++) // 控制首部，每一次减去当前值即首尾子列和 { if (max &lt; tmpSum) max = tmpSum; tmpSum -= a[j]; } } return max;}算法四递归分成两份，分别求每个分割后最大子列和，时间复杂度为 O(n*logn)/* 返回三者中最大值*/int Max3(int A, int B, int C){ return (A &gt; B) ? ((A &gt; C) ? A : C) : ((B &gt; C) ? B : C);}/* 分治*/int DivideAndConquer(int a[], int left, int right){ /*递归结束条件：子列只有一个数字*/ // 当该数为正数时，最大子列和为其本身 // 当该数为负数时，最大子列和为 0 if (left == right) { if (0 &lt; a[left]) return a[left]; return 0; } /* 分别递归找到左右最大子列和*/ int center = (left + right) / 2; int MaxLeftSum = DivideAndConquer(a, left, center); int MaxRightSum = DivideAndConquer(a, center + 1, right); /* 再分别找左右跨界最大子列和*/ int MaxLeftBorderSum = 0; int LeftBorderSum = 0; for (int i = center; i &gt;= left; i--) { // 应该从边界出发向左边找 LeftBorderSum += a[i]; if (MaxLeftBorderSum &lt; LeftBorderSum) MaxLeftBorderSum = LeftBorderSum; } int MaXRightBorderSum = 0; int RightBorderSum = 0; for (int i = center + 1; i &lt;= right; i++) { // 从边界出发向右边找 RightBorderSum += a[i]; if (MaXRightBorderSum &lt; RightBorderSum) MaXRightBorderSum = RightBorderSum; } // 最后返回分解的左边最大子列和，右边最大子列和，和跨界最大子列和三者中最大的数 return Max3(MaxLeftSum, MaxRightSum, MaXRightBorderSum + MaxLeftBorderSum);}int MaxSubseqSum4(int n, int a[]){ return DivideAndConquer(a, 0, n - 1);}算法五“贪心法”，即不从整体最优上加以考虑，只做出某种意义上的局部最优解。其实最大子列和与它的首部和尾部都没有关系，我们只关心它当前的大小。当临时和加上当前值为负时，它对之后子列和肯定没有帮助（甚至只会让之后的和更小！），我们抛弃这段临时和将它置0。int MaxSubseqSum5(int n, int a[]) // 方法五：直接累加，如果累加到当前的和为负数，置当前值或0，时间复杂度为 O(N){ int max = 0; int tmpSum = 0; for (int i = 0; i &lt; n; i++) { tmpSum += a[i]; if (tmpSum &lt; 0) { tmpSum = 0; } else if (max &lt; tmpSum) { max = tmpSum; } } return max;}时间复杂度最好，是线性的，为O(n)。very推荐，很好理解的题目2：最大子列和加强版Maximum Subsequence Sum部分题干（重点）Output Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.简单来说就是注意以下几个点（坑）：1.如果全都是负数，则输出[0 第一个数 最后一个数]2.如果原序列中除了0就是负数，如：‘0 -3 -6’，则输出【0 0 0】（这个时候sumMax肯定是0）#include &lt;iostream&gt;using namespace std;int s[100010];int main (int argc,char const *argv[]) {\tint n,cnt=0,max=-1,sum=0;\tcin &gt;&gt; n;\tint l=0,r=n-1,tl=0;\tfor(int i=0; i&lt;n; i++) {\t\tcin &gt;&gt; s[i];\t\tif(s[i]&lt;0){\t\t\tcnt++; //用于看有没有负数，如果cnt==n则都是负数\t\t}\t}\tfor(int i=0;i&lt;n;i++){\t\tsum+=s[i];\t\tif(sum&lt;0){\t\t\tsum=0;\t\t\ttl=i+1; //tl为被舍弃的下一项\t\t}\t\telse if(sum&gt;max){\t\t\tmax=sum;\t\t\tl=tl;\t\t\tr=i;\t\t}\t}\tif(cnt==n){\t\tcout &lt;&lt; \"0 \"&lt;&lt; s[0] &lt;&lt; \" \" &lt;&lt; s[n-1];\t}\telse{\t\tcout &lt;&lt; max &lt;&lt; \" \" &lt;&lt; s[l] &lt;&lt; \" \" &lt;&lt; s[r];\t} \treturn 0;}" } ]
