[ { "title": "The Definition Of The Tree", "url": "/posts/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/", "categories": "Tree", "tags": "Data Structure", "date": "2023-01-07 16:07:00 +0000", "snippet": "1.æ ‘çš„å®šä¹‰æ ‘ï¼ˆTreeï¼‰ï¼šnï¼ˆnâ‰¥0ï¼‰ä¸ªç»“ç‚¹æ„æˆçš„æœ‰é™é›†åˆå½“ n=0 æ—¶ï¼Œç§°ä¸ºç©ºæ ‘1.ç‰¹å¾å¯¹äºä»»ä¸€æ£µéç©ºæ ‘ï¼ˆnï¼0ï¼‰ï¼Œå®ƒå…·å¤‡ä»¥ä¸‹ç‰¹å¾ï¼š1)æ ‘ä¸­æœ‰ä¸ªç§°ä¸ºâ€œæ ¹ï¼ˆRootï¼‰â€çš„ç‰¹æ®Šç»“ç‚¹ï¼Œç”¨ r è¡¨ç¤º2)å…¶ä½™ç»“ç‚¹å¯åˆ†ä¸º m(m&gt;0) ä¸ªäº’ä¸ç›¸äº¤çš„æœ‰é™é›† $T _1$ $T _2$â€¦$T _m$3)å­æ ‘æ˜¯ä¸ç›¸äº¤çš„(æ•°æ˜¯éè¿é€šå›¾)4)é™¤æ ¹ç»“ç‚¹å¤–ï¼Œæ¯ä¸ªç»“ç‚¹æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªçˆ¶ç»“ç‚¹(å¯ä»¥ç”¨æ—è°±æ¥ç†è§£ï¼Œæœ€ä¸Š...", "content": "1.æ ‘çš„å®šä¹‰æ ‘ï¼ˆTreeï¼‰ï¼šnï¼ˆnâ‰¥0ï¼‰ä¸ªç»“ç‚¹æ„æˆçš„æœ‰é™é›†åˆå½“ n=0 æ—¶ï¼Œç§°ä¸ºç©ºæ ‘1.ç‰¹å¾å¯¹äºä»»ä¸€æ£µéç©ºæ ‘ï¼ˆnï¼0ï¼‰ï¼Œå®ƒå…·å¤‡ä»¥ä¸‹ç‰¹å¾ï¼š1)æ ‘ä¸­æœ‰ä¸ªç§°ä¸ºâ€œæ ¹ï¼ˆRootï¼‰â€çš„ç‰¹æ®Šç»“ç‚¹ï¼Œç”¨ r è¡¨ç¤º2)å…¶ä½™ç»“ç‚¹å¯åˆ†ä¸º m(m&gt;0) ä¸ªäº’ä¸ç›¸äº¤çš„æœ‰é™é›† $T _1$ $T _2$â€¦$T _m$3)å­æ ‘æ˜¯ä¸ç›¸äº¤çš„(æ•°æ˜¯éè¿é€šå›¾)4)é™¤æ ¹ç»“ç‚¹å¤–ï¼Œæ¯ä¸ªç»“ç‚¹æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªçˆ¶ç»“ç‚¹(å¯ä»¥ç”¨æ—è°±æ¥ç†è§£ï¼Œæœ€ä¸Šé¢çš„æ²¡æœ‰â€¦ï¼Œå…¶ä»–çš„æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªğŸ˜„)5)ä¸€æ£µ N ä¸ªç»“ç‚¹çš„æ ‘æœ‰ N-1 æ¡è¾¹(å¯ä»¥ç†è§£æˆé™¤äº†æ ¹ç»“ç‚¹æ¯ä¸ªç‚¹éƒ½æœ‰ä¸€æ¡å‘ä¸Šçš„è¾¹)2. åŸºæœ¬æœ¯è¯­1)ç»“ç‚¹çš„åº¦ï¼ˆDegreeï¼‰ï¼šç»“ç‚¹çš„å­æ ‘ä¸ªæ•°(æ¯ä¸ªç‚¹æœ‰å‡ ä¸ªå„¿å­)2)æ ‘çš„åº¦ï¼šæ ‘çš„æ‰€æœ‰ç»“ç‚¹ä¸­æœ€å¤§çš„åº¦æ•°3)å¶ç»“ç‚¹ï¼ˆLeafï¼‰ï¼šåº¦ä¸º 0 çš„ç»“ç‚¹4)çˆ¶ç»“ç‚¹ï¼ˆParentï¼‰ï¼šæœ‰å­æ ‘çš„ç»“ç‚¹æ˜¯å…¶å­æ ‘çš„æ ¹ç»“ç‚¹å«çˆ¶ç»“ç‚¹5)å­ç»“ç‚¹ï¼ˆChildï¼‰ï¼šè‹¥ A ç»“ç‚¹æ˜¯ B ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ï¼Œåˆ™ç§° B ç»“ç‚¹æ˜¯ A ç»“ç‚¹çš„å­ç»“ç‚¹ï¼Œä¹Ÿç§°å­©å­ç»“ç‚¹6)å…„å¼Ÿç»“ç‚¹ï¼ˆSiblingï¼‰ï¼šå…·æœ‰åŒä¸€çˆ¶ç»“ç‚¹çš„å„ä¸ªç»“ç‚¹å½¼æ­¤æ˜¯å…„å¼Ÿç»“ç‚¹7)è·¯å¾„ï¼šä»ç»“ç‚¹$n _1$åˆ°$n _k$çš„è·¯å¾„ä¸ºä¸€ä¸ªç»“ç‚¹åºåˆ—$n _1$$n _2$â€¦$n _k$ï¼Œå…¶ä¸­$n _i$æ˜¯$n _{i+1}$çš„çˆ¶ç»“ç‚¹8)è·¯å¾„é•¿åº¦ï¼šè·¯å¾„æ‰€åŒ…å«è¾¹çš„ä¸ªæ•°9)å­å­™ç»“ç‚¹ï¼ˆDescendantï¼‰ï¼šæŸä¸€ç»“ç‚¹çš„å­æ ‘ä¸­çš„æ‰€æœ‰ç»“ç‚¹æ˜¯è¿™ä¸ªç»“ç‚¹çš„å­å­™10)ç»“ç‚¹çš„å±‚æ¬¡ï¼ˆLevelï¼‰ï¼šè§„å®šæ ¹ç»“ç‚¹åœ¨ 1 å±‚ï¼Œå…¶ä»–ä»»ä¸€ç»“ç‚¹çš„å±‚æ•°æ˜¯å…¶çˆ¶ç»“ç‚¹çš„å±‚æ•°åŠ ä¸€11)æ ‘çš„æ·±åº¦ï¼ˆDepthï¼‰ï¼šæ ‘ä¸­æ‰€æœ‰ç»“ç‚¹ä¸­çš„æœ€å¤§å±‚æ¬¡æ˜¯è¿™æ£µæ ‘çš„æ·±åº¦(è¿™ä¸ªç»“ç‚¹ä¸€å®šæ˜¯å¶ç»“ç‚¹)3.æ•°çš„è¡¨ç¤º1.å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•â€¢ Element å­˜å€¼â€¢ FirstChild æŒ‡å‘ç¬¬ä¸€ä¸ªå„¿å­â€¢ NextSibling æŒ‡å‘ä¸‹ä¸€ä¸ªå…„å¼Ÿ2.äºŒå‰æ ‘å³åº¦ä¸º 2 çš„æ ‘äºŒå‰æ ‘å…¶å®å°±æ˜¯å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•çš„é“¾è¡¨å³ç§» 45Â° å¾—åˆ°çš„ç»“æœ2.äºŒå‰æ ‘1.å®šä¹‰1.äºŒå‰æ ‘ Tï¼šä¸€ä¸ªæœ‰ç©·çš„ç»“ç‚¹é›†åˆ2.â€‹è¿™ä¸ªé›†åˆå¯ä»¥ä¸ºç©º3.è‹¥ä¸ä¸ºç©ºï¼Œåˆ™å®ƒæ˜¯ç”±æ ¹ç»“ç‚¹å’Œç§°ä¸ºå…¶å·¦å­æ ‘$T _L$ å’Œå³å­æ ‘$T _R$çš„ä¸¤ä¸ªä¸ç›¸äº¤çš„äºŒå‰æ ‘ç»„æˆ4.äºŒå‰æ ‘çš„å­æ ‘æœ‰å·¦å³é¡ºåºä¹‹åˆ†2.äº”ç§åŸºæœ¬å½¢æ€3.ç‰¹æ®Šå½¢æ€Â·æ–œäºŒå‰æ ‘(åªæœ‰å·¦å„¿å­æˆ–åªæœ‰å³å„¿å­)Â·å®Œç¾äºŒå‰æ ‘(æ»¡äºŒå‰æ ‘)é™¤æœ€åä¸€å±‚å¶èŠ‚ç‚¹å¤–ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­ç»“ç‚¹Â·å®Œå…¨äºŒå‰æ ‘(ä¸æ˜¯é‚£ä¹ˆå®Œç¾çš„å®Œç¾äºŒå‰æ ‘ğŸ˜„)æœ‰ n ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ï¼Œå¯¹æ ‘ä¸­ç»“ç‚¹æŒ‰ä»ä¸Šè‡³ä¸‹ã€ä»å·¦åˆ°å³é¡ºåºè¿›è¡Œç¼–å·ï¼Œç¼–å·ä¸º iï¼ˆ1â‰¤iâ‰¤nï¼‰ç»“ç‚¹ä¸æ»¡äºŒå‰æ ‘ä¸­ç¼–å·ä¸º i ç»“ç‚¹åœ¨äºŒå‰æ ‘ä¸­ä½ç½®ç›¸åŒ4.é‡è¦æ€§è´¨Â·ä¸€ä¸ªäºŒå‰æ ‘ç¬¬iå±‚çš„æœ€å¤§ç»“ç‚¹æ•°ä¸ºï¼š$2^{i-1}$Â·æ·±åº¦ä¸ºkçš„äºŒå‰æ ‘æœ‰æœ€å¤§èŠ‚ç‚¹æ€»æ•°ä¸º$s^k-1$Â·å¯¹ä»»ä½•éç©ºäºŒå‰æ ‘Tï¼Œè‹¥$n_0$è¡¨ç¤ºå¶ç»“ç‚¹çš„ä¸ªæ•°ï¼Œ$n_2$è¡¨ç¤ºåº¦ä¸º2çš„ç»“ç‚¹çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆä¸¤è€…çš„å…³ç³»æ˜¯$n_0$=$n_2$+1ä¸‹é¢æˆ‘è¯æ˜ä¸€ä¸‹ï¼šå’±ä»¬ä»¥è¾¹çš„æ€»æ•°æ¥åˆ—ä¸€ä¸ªç­‰å¼ï¼Œè¯¥äºŒå‰æ ‘ä¸€å…±æœ‰ï¼ˆ$n_0$+$n_1$+$n_2$ï¼‰ä¸ªç‚¹ï¼Œæ‰€ä»¥æœ‰ï¼ˆ$n_0$+$n_1$+$n_2$ï¼‰-1æ¡è¾¹ï¼Œè€Œä¸åŒç§ç»“ç‚¹å¯¹è¾¹çš„æ€»æ•°çš„è´¡çŒ®ä¸º$n_0$è´¡çŒ®0æ¡è¾¹ï¼Œ$n_1$è´¡çŒ®ä¸€æ¡è¾¹ï¼Œ$n_2$è´¡çŒ®ä¸¤æ¡è¾¹æ‰€ä»¥å¯ä»¥åˆ—å‡º$n_0$+$n_1$+$n_2$-1 = $n_0$0+$n_1$1+$n_2$*2æœ€åå¯ä»¥å¾—å‡º$n_0$=$n_2$+15.æŠ½è±¡æ•°æ®ç±»å‹å®šä¹‰Â·ç±»å‹åç§°ï¼šäºŒå‰æ ‘Â·æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰ç©·çš„ç»“ç‚¹é›†åˆï¼Œè‹¥ä¸ä¸ºç©ºï¼Œåˆ™ç”±æ ¹ç»“ç‚¹å’Œå…¶å·¦ã€å³äºŒå‰å­æ ‘ç»„æˆÂ·æ“ä½œé›†ï¼šBT âˆˆ BinTreeï¼ŒItem âˆˆ ElementTypeä¸»è¦æ“ä½œæœ‰Boolean IsEmpty(BinTree BT)ï¼šåˆ¤åˆ« BT æ˜¯å¦ä¸ºç©ºvoid Traversal(BinTree BT)ï¼šéå†ï¼ŒæŒ‰æŸé¡ºåºè®¿é—®æ¯ä¸ªç»“ç‚¹//æœ€é‡è¦å•¦ï¼ï¼ï¼ï¼BinTree CreatBinTree()ï¼šåˆ›å»ºä¸€ä¸ªäºŒå‰æ ‘å¸¸è§çš„éå†æ–¹æ³•æœ‰void PreOrderTraversal(BinTree BT)ï¼šå…ˆåºâ€”â€”æ ¹ã€å·¦å­æ ‘ã€å³å­æ ‘void InOrderTraversal(BinTree BT)ï¼šä¸­åºâ€”â€”å·¦å­æ ‘ã€æ ¹ã€å³å­æ ‘void PostOrderTraversal(BinTree BT)ï¼šååºâ€”â€”å·¦å­æ ‘ã€å³å­æ ‘ã€æ ¹void LevelOrderTraversal(BinTree BT)ï¼šå±‚æ¬¡éå†ï¼Œä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³1.é¡ºåºå­˜å‚¨ç»“æ„(å»ºç«‹å‰æä¸ºå®Œå…¨äºŒå‰æ ‘ï¼Œä¸å®Œå…¨è¦å‡è£…è¡¥å…¨ï¼Œå¹¶åƒå®Œå…¨äºŒå‰æ ‘é‚£æ ·æ ‡å·ï¼Œä¸»è¦æ˜¯æ ‡å·æ“ä½œ)æŒ‰ä»ä¸Šè‡³ä¸‹ã€ä»å·¦åˆ°å³é¡ºåºå­˜å‚¨ n ä¸ªç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„ç»“ç‚¹çˆ¶å­å…³ç³»ï¼šÂ·éæ ¹ç»“ç‚¹ï¼ˆåºå· i &gt; 1ï¼‰çš„çˆ¶ç»“ç‚¹çš„åºå·æ˜¯ âŒŠi/2âŒ‹ï¼ˆå‘ä¸‹å–æ•´ï¼‰Â·ç»“ç‚¹ï¼ˆåºå·ä¸º iï¼‰çš„å·¦å­©å­ç»“ç‚¹çš„åºå·æ˜¯ 2i(æˆç«‹æ¡ä»¶ï¼š2i â‰¤nï¼Œå¦åˆ™æ²¡æœ‰å·¦å­©å­)Â·ç»“ç‚¹ï¼ˆåºå·ä¸º iï¼‰çš„å³å­©å­ç»“ç‚¹çš„åºå·æ˜¯ 2i+1(æˆç«‹æ¡ä»¶ï¼š2i+1 â‰¤ nï¼Œå¦åˆ™æ²¡æœ‰å³å­©å­)2.é“¾è¡¨å­˜å‚¨ä¸‹é¢ç»™å‡ºç»“æ„ä½“typedef struct TreeNode *BinTree;struct TreeNode{\tElement Data; // å­˜å€¼ \tBinTree Left; // å·¦å„¿å­ç»“ç‚¹ \tBinTree Right; // å³å„¿å­ç»“ç‚¹ };//ä¸‹é¢è®²è¯¦ç»†å±•å¼€äºŒå‰æ ‘çš„ä¾¿åˆ©ï¼Œæ‰€ä»¥ç‹¬ç«‹å‡ºæ¥å–½" }, { "title": "Queue", "url": "/posts/%E9%98%9F%E5%88%97/", "categories": "Linear Structure", "tags": "Data Structure", "date": "2023-01-04 16:40:00 +0000", "snippet": "é˜Ÿåˆ—ä»€ä¹ˆæ˜¯é˜Ÿåˆ—é˜Ÿåˆ—ï¼ˆQUeueï¼‰ï¼šå…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨â€”â€”æœ¬è´¨è¿˜æ˜¯çº¿æ€§è¡¨1.æ’å…¥å’Œåˆ é™¤æ“ä½œï¼šåªåœ¨ä¸€ç«¯ï¼ˆfrontï¼‰åšæ’å…¥ï¼Œè€Œåœ¨å¦ä¸€ç«¯ï¼ˆrearï¼‰åˆ é™¤2.æ’å…¥æ•°æ®ï¼šå…¥é˜Ÿåˆ—ï¼ˆAddQï¼‰3.åˆ é™¤æ•°æ®ï¼šå‡ºé˜Ÿåˆ—ï¼ˆDeleteQï¼‰4.åå…¥å…ˆå‡ºï¼šFIFOé˜Ÿåˆ—çš„æŠ½è±¡æ•°æ®ç±»å‹æè¿°æ•°æ®ç±»å‹ï¼šé˜Ÿåˆ—ï¼ˆQueueï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰ 0 ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸º MaxSize çš„é˜Ÿåˆ— Q âˆˆ St...", "content": "é˜Ÿåˆ—ä»€ä¹ˆæ˜¯é˜Ÿåˆ—é˜Ÿåˆ—ï¼ˆQUeueï¼‰ï¼šå…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨â€”â€”æœ¬è´¨è¿˜æ˜¯çº¿æ€§è¡¨1.æ’å…¥å’Œåˆ é™¤æ“ä½œï¼šåªåœ¨ä¸€ç«¯ï¼ˆfrontï¼‰åšæ’å…¥ï¼Œè€Œåœ¨å¦ä¸€ç«¯ï¼ˆrearï¼‰åˆ é™¤2.æ’å…¥æ•°æ®ï¼šå…¥é˜Ÿåˆ—ï¼ˆAddQï¼‰3.åˆ é™¤æ•°æ®ï¼šå‡ºé˜Ÿåˆ—ï¼ˆDeleteQï¼‰4.åå…¥å…ˆå‡ºï¼šFIFOé˜Ÿåˆ—çš„æŠ½è±¡æ•°æ®ç±»å‹æè¿°æ•°æ®ç±»å‹ï¼šé˜Ÿåˆ—ï¼ˆQueueï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰ 0 ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸º MaxSize çš„é˜Ÿåˆ— Q âˆˆ Stackï¼Œé˜Ÿåˆ—å…ƒç´  item âˆˆ ElementTypeé˜Ÿåˆ—çš„åŸºæœ¬æ“ä½œä¸»è¦æœ‰Queue CreateQueue(int MaxSize)ï¼šç”Ÿæˆé•¿åº¦ä¸º MaxSize çš„ç©ºé˜Ÿåˆ—int IsFull(Queue Q)ï¼šåˆ¤æ–­é˜Ÿåˆ— Q æ˜¯å·²æ»¡void AddQ(Queue Q,ElementType item)ï¼šå°†æ•°æ®å…ƒç´  item æ’å…¥é˜Ÿåˆ— Q ä¸­int IsEmpty(Queue Q)ï¼šåˆ¤æ–­é˜Ÿåˆ— Q æ˜¯å¦ä¸ºç©ºElementType DeleteQ(Queue Q)ï¼šå°†é˜Ÿå¤´æ•°æ®å…ƒç´ ä»é˜Ÿåˆ—ä¸­åˆ é™¤å¹¶è¿”å›é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨å®ç°é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨ç»“æ„é€šå¸¸ç”±ä¸€ä¸ªä¸€ç»´æ•°ç»„å’Œä¸€ä¸ªè®°å½•é˜Ÿåˆ—å¤´å…ƒç´ ä½ç½®çš„å˜é‡frontå’Œå°¾å…ƒç´ rearç»„æˆï¼Œä¸€èˆ¬è®©ä»–ä»¬ä¸€å¼€å§‹éƒ½ä¸º-1,å³ä¸€å¼€å§‹éƒ½ä¸ºç©ºä½¿ç”¨é˜Ÿåˆ—è¿™ç§çº¿æ€§ç»“æ„æ—¶ï¼Œä»…ä½¿ç”¨n-1ç§å…ƒç´ ,å› ä¸ºæœ‰nä¸ªå…ƒç´ ï¼Œå³æœ‰n+1ç§æƒ…å†µï¼Œfrontå’Œrearä¹‹é—´çš„å·®è·æœ‰nç§ï¼Œæ‰€ä»¥ä¸èƒ½å®Œå…¨è¡¨è¿°ï¼ˆparticularlyé‡åˆæˆ–ç©ºï¼‰é˜Ÿåˆ—æ˜¯ç¯å½¢å­˜å‚¨ï¼Œä»¥ä¾¿äºä¸æ–­æ’å…¥å’Œåˆ é™¤#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ElementType;typedef struct SNode *Stack;typedef int ElementType; // ElementType æš‚æ—¶å®šä¹‰ä¸º int ç±»å‹struct SNode{ ElementType Data; Stack Next;};// Topåº”è¯¥åœ¨é“¾è¡¨çš„å·¦ç«¯ï¼ˆå¤´éƒ¨ï¼‰è¿›è¡Œï¼ŒåŸå› æ˜¯æ–¹ä¾¿pushå’Œpopï¼Œè‹¥æ˜¯åœ¨å°¾ç«¯pushæ˜¯æ–¹ä¾¿çš„ï¼Œpopä¸æ–¹ä¾¿ï¼Œå› ä¸ºæ˜¯å•å‘é“¾è¡¨Stack CreateStack(); // åˆå§‹åŒ–é“¾æ ˆint IsEmpty(Stack S); // åˆ¤æ–­é“¾æ ˆæ˜¯å¦ä¸ºç©ºvoid Push(Stack S, ElementType item); // å…¥æ ˆElementType Pop(Stack S); // å‡ºæ ˆStack CreateStack() // å»ºç«‹ä¸€ä¸ªå †æ ˆçš„å¤´ç»“ç‚¹å¹¶è¿”å›æŒ‡é’ˆ{ Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;}int IsEmpty(Stack S){ return (S-&gt;Next == NULL); // é€»è¾‘è¿ç®— // åˆ¤æ–­å †æ ˆSæ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ºç©ºåˆ™è¿”å›æ•´æ•°1ï¼Œå¦åˆ™è¿”å›0}void Push(ElementType item, Stack S){ // å°†å…ƒç´ itemå‹å…¥å †æ ˆS Stack TmpCell = (Stack)malloc(sizeof(struct SNode)); TmpCell-&gt;Data = item; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell;}//åˆ é™¤å¹¶è¿”å›å †æ ˆSçš„æ ˆé¡¶å…ƒç´ ElementType Pop(Stack S){ Stack FirstCell; ElementType TopVal; if (IsEmpty(S)) { cout &lt;&lt; \"å †æ ˆç©º\" &lt;&lt; endl; return NULL; } else { FirstCell = S-&gt;Next; S-&gt;Next = FirstCell-&gt;Next; TopVal = S-&gt;Data; free(FirstCell); return TopVal; }}int main(){ return 0;}é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨å®ç°é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨ç»“æ„ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªå•é“¾è¡¨æ¥å®ç°ã€‚æ’å…¥å’Œåˆ é™¤æ“ä½œåˆ†åˆ«åœ¨é“¾è¡¨çš„ä¸¤å¤´è¿›è¡ŒQï¼šé˜Ÿåˆ—æŒ‡é’ˆfrontå’Œrearåº”è¯¥åˆ†åˆ«æŒ‡å‘é“¾è¡¨çš„å“ªä¸€å¤´Aï¼šåˆ é™¤åœ¨å¤´ï¼Œæ·»åŠ åœ¨é“¾è¡¨å°¾éƒ¨ï¼ˆä¸èƒ½å€’ç½®ï¼‰Q:why?A:å¦‚æœé˜Ÿåˆ—çš„åˆ é™¤æ“ä½œå¦‚æœåœ¨é“¾è¡¨å°¾è¿›è¡Œï¼Œç”±äºæ˜¯å•å‘é“¾è¡¨ï¼Œæ‰€ä»¥åœ¨é“¾è¡¨å°¾åˆ é™¤åä¼šä¸¢å¤±æ•´ä¸ªé“¾è¡¨ï¼Œè€Œæ’å…¥æ“ä½œåœ¨é“¾è¡¨å¤´æˆ–è€…é“¾è¡¨å°¾éƒ½æ¯”è¾ƒå¥½æ“ä½œ#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ElementType;typedef struct QNode *Queue;struct Node // ä¸»å¹²éƒ¨åˆ†{ ElementType Data; struct Node *Next;};struct QNode{ struct Node *rear; // æŒ‡å‘é˜Ÿå°¾ç»“ç‚¹ struct Node *front; // æŒ‡å‘é˜Ÿå¤´ç»“ç‚¹};Queue CreateQueue(); // åˆå§‹åŒ–é˜Ÿåˆ—void AddQ(Queue Q, ElementType item); // å…¥é˜ŸElementType DeleteQ(Queue Q); // å‡ºé˜Ÿint IsEmpty(Queue Q); // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºç”±äºæ­¤å¤„æœ‰ä¸¤ç§ç»“æ„ï¼Œæ¯”è¾ƒæŠ½è±¡,ç»™å‡ºå›¾ç‰‡ä»¥åŠ©äºç†è§£ç»“æ„ä½“Nodeä¸ºé˜Ÿåˆ—çš„ä¸»å¹²ç»“æ„ï¼Œå¯ä»¥æœ‰è‹¥å¹²ä¸ªç»“æ„ä½“QNodeåœ¨è¡¨å¤´å­˜åœ¨ï¼Œåªæœ‰ä¸€ä¸ªï¼Œç”¨äºå­˜å‚¨frontå’Œrear// åˆå§‹åŒ–Queue CreateQueue(){ Queue Q; Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;front = NULL; Q-&gt;rear = NULL; return Q;}// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ç©ºint IsEmpty(Queue Q){ return (Q-&gt;front == NULL);}// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾å¼é˜Ÿåˆ—å‡ºé˜Ÿæ“ä½œElementType DeleteQ(Queue Q){ struct Node *FrontCell; ElementType FrontItem; if (IsEmpty) { cout &lt;&lt; \"é˜Ÿåˆ—ç©º\" &lt;&lt; endl; return 0; } FrontCell = Q-&gt;front; // ç”¨äºè¿”å›é˜Ÿåˆ—é¡¶å…ƒç´  if (Q-&gt;front == Q-&gt;rear) // è‹¥é˜Ÿåˆ—åªæœ‰ä¸€ä¸ªå…ƒç´  Q-&gt;front == Q-&gt;rear == NULL; else Q-&gt;front = Q-&gt;front-&gt;Next; // æ— è®ºæ˜¯ç¬¬äºŒä¸ªifè¿˜æ˜¯elseéƒ½éœ€è¦è¦æ‰§è¡Œä¸‹åˆ—æ“ä½œ FrontItem = FrontCell-&gt;Data; free(FrontCell); return FrontItem; // è¿”å›é˜Ÿåˆ—é¦–å…ƒç´ }// å…¥é˜Ÿæ“ä½œ,æ¯æ¬¡å…¥é˜Ÿå°±æ˜¯æ’å…¥ä¸€ä¸ªstruct Nodeç±»å‹çš„ä¸€ä¸ªç»“æ„void AddQ(Queue Q, ElementType item){ struct Node *node = (struct Node *)malloc(sizeof(struct Node)); node-&gt;Data = item; node-&gt;Next = NULL; if (IsEmpty) { Q-&gt;front = node; Q-&gt;rear = node; } else // ä¸ä¸ºç©º { Q-&gt;rear-&gt;Next = node; // æŠŠæ–°ç»“ç‚¹æ¥åœ¨åŸé˜Ÿåˆ—åé¢ Q-&gt;rear = node; // rearå§‹ç»ˆæŒ‡å‘é˜Ÿåˆ—å°¾ç«¯ }}int main(){ return 0;}" }, { "title": "stack", "url": "/posts/%E5%A0%86%E6%A0%88/", "categories": "Linear Structure", "tags": "Data Structure", "date": "2023-01-04 16:40:00 +0000", "snippet": "å †æ ˆä»€ä¹ˆæ˜¯å †æ ˆå †æ ˆï¼ˆstackï¼‰ï¼šå…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨â€”â€”æœ¬è´¨è¿˜æ˜¯çº¿æ€§è¡¨1.åªåœ¨ä¸€ç«¯ï¼ˆæ ˆé¡¶ï¼ŒTopï¼‰åšæ’å…¥ã€åˆ é™¤2.æ’å…¥æ•°æ®ï¼šå…¥æ ˆï¼ˆPushï¼‰3.åˆ é™¤æ•°æ®ï¼šå‡ºæ ˆï¼ˆPopï¼‰4.åå…¥å…ˆå‡ºï¼šLast In First Outï¼ˆLIFOï¼‰å †æ ˆçš„æŠ½è±¡æ•°æ®ç±»å‹æè¿°æ•°æ®ç±»å‹ï¼šå †æ ˆï¼ˆstackï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰ 0 ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸º MaxSize çš„å †æ ˆ S âˆˆ Stackï¼Œå †...", "content": "å †æ ˆä»€ä¹ˆæ˜¯å †æ ˆå †æ ˆï¼ˆstackï¼‰ï¼šå…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨â€”â€”æœ¬è´¨è¿˜æ˜¯çº¿æ€§è¡¨1.åªåœ¨ä¸€ç«¯ï¼ˆæ ˆé¡¶ï¼ŒTopï¼‰åšæ’å…¥ã€åˆ é™¤2.æ’å…¥æ•°æ®ï¼šå…¥æ ˆï¼ˆPushï¼‰3.åˆ é™¤æ•°æ®ï¼šå‡ºæ ˆï¼ˆPopï¼‰4.åå…¥å…ˆå‡ºï¼šLast In First Outï¼ˆLIFOï¼‰å †æ ˆçš„æŠ½è±¡æ•°æ®ç±»å‹æè¿°æ•°æ®ç±»å‹ï¼šå †æ ˆï¼ˆstackï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰ 0 ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸º MaxSize çš„å †æ ˆ S âˆˆ Stackï¼Œå †æ ˆå…ƒç´  item âˆˆ ElementTypeå †æ ˆçš„åŸºæœ¬æ“ä½œä¸»è¦æœ‰Stack CreateStack(int Maxsize):ç”Ÿæˆç©ºå †æ ˆï¼Œå…¶æœ€å¤§é•¿åº¦ä¸ºMaxSizeint IsFull(Stack S,int MaxSize)ï¼šåˆ¤æ–­å †æ ˆ S æ˜¯å¦å·²æ»¡void Push(Stack S,ElementType item)ï¼šå°†å…ƒç´  item å‹å…¥å †æ ˆint IsEmpty(Stack S)ï¼šåˆ¤æ–­å †æ ˆ S æ˜¯å¦ä¸ºç©ºElementType Pop(Stack S)ï¼šåˆ é™¤å¹¶è¿”å›æ ˆé¡¶å…ƒç´ å †æ ˆçš„é¡ºåºå­˜å‚¨å®ç°æ ˆçš„é¡ºåºå­˜å‚¨å®ç°é€šå¸¸ç”±ä¸€ä¸ªä¸€ç»´æ•°ç»„å’Œä¸€ä¸ªè®°å½•æ ˆé¡¶å…ƒç´ ä½ç½®çš„å˜é‡ç»„æˆï¼ˆéå¸¸éå¸¸ç±»ä¼¼äºçº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨ç»“æ„ï¼‰#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100 // å †æ ˆå…ƒç´ çš„æœ€å¤§ä¸ªæ•°typedef int ElementType; // ElementType æš‚æ—¶å®šä¹‰ä¸º int ç±»å‹typedef struct SNode *Stack;struct SNode{ ElementType Data[MAXSIZE]; // å­˜å‚¨å †æ ˆå…ƒç´  int Top; // è®°å½•æ ˆé¡¶å…ƒç´ ä¸‹æ ‡};// Top=-1ä»£è¡¨å †æ ˆç©ºï¼ŒTop=MAXSIZE-1è¡¨ç¤ºæ ˆå †æ»¡ï¼Œtopçš„å€¼å°±æ˜¯æ•°ç»„çš„ä¸‹æ ‡Stack S;// å‡½æ•°æ±‡æ€»Stack CreateStack(); // åˆå§‹åŒ–å †æ ˆint IsFull(Stack S); // åˆ¤æ–­å †æ ˆæ˜¯å¦å·²æ»¡int IsEmpty(Stack S); // åˆ¤æ–­å †æ ˆæ˜¯å¦ä¸ºç©ºvoid Push(Stack S, ElementType item); // å…¥æ ˆElementType Pop(Stack S); // å‡ºæ ˆStack CreateStack(){ S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Top = -1; return S;}// æ˜¯å¦å·²æ»¡int IsFull(Stack S){ return (S-&gt;Top == MAXSIZE - 1);}// æ˜¯å¦ä¸ºç©ºint IsEmpty(Stack S){ return (S-&gt;Top == -1);}// å…¥æ ˆvoid Push(Stack S, ElementType item){ if (S-&gt;Top + 1 == MAXSIZE) { cout &lt;&lt; \"å †æ ˆæ»¡\" &lt;&lt; endl; return; } else { S-&gt;Data[++(S-&gt;Top)] = item; return; }}// å‡ºæ ˆElementType Pop(Stack S){ if (S-&gt;Top == -1) { cout &lt;&lt; \"å †æ ˆç©º\" &lt;&lt; endl; return 0; } else return (S-&gt;Data[(S-&gt;Top)--]);}int main(){ return 0;}å †æ ˆçš„é“¾å¼å­˜å‚¨å®ç°å†æ¬¡å¼ºåŒ–æ€æƒ³ï¼Œå †æ ˆå°±æ˜¯æ“ä½œå—çº¦æŸçš„çº¿æ€§è¡¨ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼æ ˆçš„é“¾å¼å­˜å‚¨ç»“æ„å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå•é“¾è¡¨ï¼Œå«åšé“¾æ ˆã€‚æ’å…¥å’Œåˆ é™¤æ“ä½œåªèƒ½åœ¨é“¾æ ˆçš„æ ˆé¡¶è¿›è¡Œ#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ElementType;typedef struct SNode *Stack;typedef int ElementType; // ElementType æš‚æ—¶å®šä¹‰ä¸º int ç±»å‹struct SNode{ ElementType Data; Stack Next;};// Topåº”è¯¥åœ¨é“¾è¡¨çš„å·¦ç«¯ï¼ˆå¤´éƒ¨ï¼‰è¿›è¡Œï¼ŒåŸå› æ˜¯æ–¹ä¾¿pushå’Œpopï¼Œè‹¥æ˜¯åœ¨å°¾ç«¯pushæ˜¯æ–¹ä¾¿çš„ï¼Œpopä¸æ–¹ä¾¿ï¼Œå› ä¸ºæ˜¯å•å‘é“¾è¡¨Stack CreateStack(); // åˆå§‹åŒ–é“¾æ ˆint IsEmpty(Stack S); // åˆ¤æ–­é“¾æ ˆæ˜¯å¦ä¸ºç©ºvoid Push(Stack S, ElementType item); // å…¥æ ˆElementType Pop(Stack S); // å‡ºæ ˆStack CreateStack() // å»ºç«‹ä¸€ä¸ªå †æ ˆçš„å¤´ç»“ç‚¹å¹¶è¿”å›æŒ‡é’ˆ{ Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;}int IsEmpty(Stack S){ return (S-&gt;Next == NULL); // é€»è¾‘è¿ç®— // åˆ¤æ–­å †æ ˆSæ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ºç©ºåˆ™è¿”å›æ•´æ•°1ï¼Œå¦åˆ™è¿”å›0}void Push(ElementType item, Stack S){ // å°†å…ƒç´ itemå‹å…¥å †æ ˆS Stack TmpCell = (Stack)malloc(sizeof(struct SNode)); TmpCell-&gt;Data = item; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell;}//åˆ é™¤å¹¶è¿”å›å †æ ˆSçš„æ ˆé¡¶å…ƒç´ ElementType Pop(Stack S){ Stack FirstCell; ElementType TopVal; if (IsEmpty(S)) { cout &lt;&lt; \"å †æ ˆç©º\" &lt;&lt; endl; return NULL; } else { FirstCell = S-&gt;Next; S-&gt;Next = FirstCell-&gt;Next; TopVal = S-&gt;Data; free(FirstCell); return TopVal; }}int main(){ return 0;}" }, { "title": "List", "url": "/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/", "categories": "Linear Structure", "tags": "Data Structure", "date": "2023-01-04 15:00:00 +0000", "snippet": "çº¿æ€§è¡¨(ç»´åŸºç™¾ç§‘)1.ä»€ä¹ˆæ˜¯çº¿æ€§è¡¨çº¿æ€§è¡¨ï¼šç”±åŒç§ç±»å‹æ•°æ®å…ƒç´ æ„æˆçš„çº¿æ€§ç»“æ„ï¼š1.è¡¨ä¸­å…ƒç´ ä¸ªæ•°ç§°ä¸ºçº¿æ€§è¡¨çš„é•¿åº¦2.çº¿æ€§è¡¨ä¸­æ²¡æœ‰å…ƒç´ æ—¶ï¼Œç§°ä¸ºç©ºè¡¨3.è¡¨çš„èµ·å§‹ä½ç½®ç§°ä¸ºè¡¨å¤´ï¼Œè¡¨çš„ç»“æŸä½ç½®ç§°ä¸ºè¡¨å°¾//æˆ‘è®¤ä¸ºçº¿æ€§è¡¨æ˜¯æœ€é‡è¦çš„çº¿æ€§ç»“æ„ï¼Œå› ä¸ºå…¶ä»–çº¿æ€§ç»“æ„éƒ½æ˜¯åœ¨çº¿æ€§è¡¨çš„åŸºç¡€ä¸Šæ¥å®ç°çš„ï¼ŒæŒæ¡å¥½çº¿æ€§è¡¨çš„ç›¸å…³æ“ä½œï¼Œåˆ«çš„çº¿æ€§ç»“æ„å°±hiå¾ˆç®€å•å•¦ï¼ï¼2.çº¿æ€§è¡¨çš„æŠ½è±¡æ•°æ®ç»“æ„ç±»å‹æè¿°1.ç±»å‹åç§°ï¼šçº¿æ€§è¡¨ï¼ˆListï¼‰2.æ•°æ®...", "content": "çº¿æ€§è¡¨(ç»´åŸºç™¾ç§‘)1.ä»€ä¹ˆæ˜¯çº¿æ€§è¡¨çº¿æ€§è¡¨ï¼šç”±åŒç§ç±»å‹æ•°æ®å…ƒç´ æ„æˆçš„çº¿æ€§ç»“æ„ï¼š1.è¡¨ä¸­å…ƒç´ ä¸ªæ•°ç§°ä¸ºçº¿æ€§è¡¨çš„é•¿åº¦2.çº¿æ€§è¡¨ä¸­æ²¡æœ‰å…ƒç´ æ—¶ï¼Œç§°ä¸ºç©ºè¡¨3.è¡¨çš„èµ·å§‹ä½ç½®ç§°ä¸ºè¡¨å¤´ï¼Œè¡¨çš„ç»“æŸä½ç½®ç§°ä¸ºè¡¨å°¾//æˆ‘è®¤ä¸ºçº¿æ€§è¡¨æ˜¯æœ€é‡è¦çš„çº¿æ€§ç»“æ„ï¼Œå› ä¸ºå…¶ä»–çº¿æ€§ç»“æ„éƒ½æ˜¯åœ¨çº¿æ€§è¡¨çš„åŸºç¡€ä¸Šæ¥å®ç°çš„ï¼ŒæŒæ¡å¥½çº¿æ€§è¡¨çš„ç›¸å…³æ“ä½œï¼Œåˆ«çš„çº¿æ€§ç»“æ„å°±hiå¾ˆç®€å•å•¦ï¼ï¼2.çº¿æ€§è¡¨çš„æŠ½è±¡æ•°æ®ç»“æ„ç±»å‹æè¿°1.ç±»å‹åç§°ï¼šçº¿æ€§è¡¨ï¼ˆListï¼‰2.æ•°æ®å¯¹è±¡é›†ï¼šçº¿æ€§è¡¨æ˜¯ n (â‰¥0) ä¸ªå…ƒç´ æ„æˆçš„æœ‰åºåºåˆ—($a_1$,$a_2$,â€¦,$a_n$)3.æ“ä½œé›†ï¼šçº¿æ€§è¡¨LâˆˆListï¼Œæ•´æ•°iè¡¨ç¤ºä½ç½®ï¼Œå…ƒç´ XâˆˆElementTypeçº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œæœ‰List MakeEmpty():åˆå§‹åŒ–ä¸€ä¸ªç©ºçº¿æ€§è¡¨ElementType FindKth(int k,List L):æ ¹æ®åºåˆ—kï¼Œè¿”å›ç›¸åº”å…ƒç´ int Find(ElementType X,List L)ï¼šåœ¨çº¿æ€§è¡¨Lä¸­æŸ¥æ‰¾Xçš„ç¬¬ä¸€æ¬¡å‡ºç°ä½ç½®void Delete(int i,List L):åˆ é™¤æŒ‡å®šåºåˆ—içš„å…ƒç´ int Length(List L):è¿”å›çº¿æ€§è¡¨Lçš„é•¿åº¦n1.çº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨å®ç°åˆ©ç”¨æ•°ç»„çš„è¿ç»­å­˜å‚¨ç©ºé—´é¡ºåºå­˜æ”¾çº¿æ€§è¡¨çš„ä¸ªå…ƒç´ æ³¨ï¼šé¡ºåºå­˜å‚¨ä¸­çš„åºå·æ˜¯ä¸‹æ ‡ï¼Œä»0å¼€å§‹#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100typedef int ElementType; // ElementType æš‚æ—¶å®šä¹‰ä¸º int ç±»å‹typedef struct LNode *List;struct LNode{ ElementType Data[MAXSIZE]; int Last; // ç”¨äºè®¿é—®é•¿åº¦};List PtrL;// è®¿é—®ä¸‹æ ‡ä¸º1çš„å…ƒç´ ï¼šL.Data[i]æˆ–PtrL-&gt;Data[i]// çº¿æ€§è¡¨çš„é•¿åº¦ï¼šL.Last+1æˆ–PtrL-&gt;Last+1// è®¿é—®æœ€å¤§è§’æ ‡æ˜¯æœ€å¤§é•¿åº¦å‡ä¸€ï¼Œsoæœ€å¤§ä¸‹è§’æ ‡æ˜¯PtrL-&gt;Last// çº¿æ€§è¡¨çš„é¡ºå¼å­˜å‚¨å®ç°// 1.å»ºç«‹ç©ºè¡¨ï¼Œä¸éœ€è¦å‚æ•°List MakeEmpty(){ List PtrL; PtrL = (List)malloc(sizeof(struct LNode)); PtrL-&gt;Last = -1; // æ²¡æœ‰å…ƒç´ å°±æ˜¯è´Ÿä¸€ï¼Œå› ä¸ºéœ€è¦ç”¨PtrL-&gt;Last+1æ¥è¡¨ç¤ºçº¿æ€§è¡¨çš„é•¿åº¦ return PtrL;}// 2.æŸ¥æ‰¾æœ‰æ²¡æœ‰Xå…ƒç´ ï¼Œå¹¶è¿”å›Xçš„ä½ç½®// æŒ‰åºæŸ¥æ‰¾int Find(ElementType X, List PtrL) // ElementType Xè¢«æ‰¾çš„ï¼ŒList PtrLä¼ è¿›æ¥çš„ç»“æ„ä½“æŒ‡é’ˆï¼Œç”¨äºè®¿é—®æ•´ä¸ªç»“æ„{ int i = 0; while (i &lt; PtrL-&gt;Last + 1 &amp;&amp; PtrL-&gt;Data[i] != X) // PtrL-&gt;Data[i] == Xçš„æ—¶å€™è¯´æ˜æ‰¾åˆ°äº†ï¼Œå¦åˆ™å°±ä¸æ–­çš„èµ° i++; // é€€å‡ºå¾ªç¯æœ‰ä¸¤ç§å¯èƒ½1.æ‰¾åˆ°äº†ï¼Œ2è¶Šç•Œäº† if (i &gt;= PtrL-&gt;Last + 1) return -1; else return i; // æ‰¾åˆ°åè¿”å›çš„æ˜¯å­˜å‚¨ä½ç½®} // å¹³å‡æ¬¡æ•°ï¼ˆn+1ï¼‰/2ï¼Œæ—¶é—´å¤æ‚åº¦Oï¼ˆnï¼‰// 3.æ’å…¥ï¼ˆç¬¬i(1â‰¤iâ‰¤n+1) ä¸ªä½ç½®æ’å…¥ä¸€ä¸ªå€¼ä¸ºXçš„æ–°å…ƒç´ ï¼‰void Insert(ElementType X, int i, List PtrL)// æ³¨æ„ç¬¬iä¸ªä½ç½®çš„ä¸‹è§’æ ‡æ˜¯i-1// å…ˆç§»åŠ¨å†æ’å…¥ï¼Œå…ˆæŠŠç¬¬nä¸ªå…ƒç´ -&gt;n+1ï¼Œå†å°†ç¬¬iä¸ªå…ƒç´ ä¹‹åçš„å…ƒç´ ä»¥æ­¤å‘å{ int j; if (PtrL-&gt;Last + 1 == MAXSIZE) { cout &lt;&lt; \"è¡¨æ»¡\" &lt;&lt; endl; return; } if (i &lt; 1 || i &gt; PtrL-&gt;Last + 2) { cout &lt;&lt; \"ä½ç½®ä¸åˆæ³•\" &lt;&lt; endl; return; } for (j = PtrL-&gt;Last; j &gt;= i - 1; j--) // j=i-1çš„æ—¶å€™é€€å‡ºå¾ªç¯ PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; // å°†ai~anå€’åºå‘åç§»åŠ¨ PtrL-&gt;Data[i - 1] = X; // æ–°å…ƒç´ æ’å…¥ PtrL-&gt;Last++; // æœ€å¤§é•¿åº¦åŠ ä¸€ return; // å¯ä»¥å»æ‰} // å¹³å‡æ¬¡æ•°ï¼ˆn+1ï¼‰/2ï¼Œæ—¶é—´å¤æ‚åº¦Oï¼ˆnï¼‰// 4.åˆ é™¤ï¼ˆåˆ é™¤è¡¨ç¬¬i(1â‰¤iâ‰¤n)ä¸ªä½ç½®ä¸Šçš„å…ƒç´ ï¼‰ **1â‰¤iâ‰¤nå¯¹åº”æ•°ç»„ä¸‹æ ‡0~n-1// åˆ é™¤ç¬¬iä¸ªå…ƒç´ ï¼Œå°†åé¢çš„å…ƒç´ ä¾æ¬¡å‘å‰ç§»åŠ¨ï¼Œi-&gt;i-1...æŒ‰ç…§ä»å·¦å¾€å³void Delete(int i, List PtrL){ int j; if (i &lt; 1 || i &gt; PtrL-&gt;Last + 1) //æ£€æŸ¥ç©ºè¡¨åŠåˆ é™¤ä½ç½®çš„åˆæ³•æ€§ { printf(\"ä¸å­˜åœ¨ç¬¬%dä¸ªå…ƒç´ \", i); return; } for (j = i; j &lt;= PtrL-&gt;Last;j++) PtrL-&gt;Data[j - 1] = PtrL-&gt;Data[j]; // å°†aj+1~ané¡ºåºå‘å‰ç§»åŠ¨ PtrL-&gt;Last--; //Listä»æŒ‡å‘æœ€åå…ƒç´ } // å¹³å‡æ¬¡æ•°ï¼ˆn+1ï¼‰/2ï¼Œæ—¶é—´å¤æ‚åº¦Oï¼ˆnï¼‰// è¡¨é•¿int Length(List L){ return L-&gt;Last + 1;}int main(){ return 0;}2.çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨å®ç°ä¸è¦æ±‚é€»è¾‘ä¸Šç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ç‰©ç†ä¹Ÿç›¸é‚»ï¼›é€šè¿‡â€œé“¾â€å»ºç«‹èµ·æ•°æ®å…ƒç´ ä¹‹é—´çš„æ•°æ®é€»è¾‘æ’å…¥åˆ é™¤ä¸éœ€è¦ç§»åŠ¨æ•°æ®å…ƒç´ ï¼Œåªéœ€è¦ä¿®â€œæ”¹é“¾â€#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100typedef int ElementType; // ElementType æš‚æ—¶å®šä¹‰ä¸º int ç±»å‹typedef struct LNode *List;struct LNode{ ElementType Data; List Next; // ç”¨äºè®¿é—®é•¿åº¦};struct LNode L;List PtrL;// 1.æ±‚è¡¨é•¿int Length(List PtrL){ List p = PtrL; int idx = 0; // è®¡æ•°å™¨ç”¨äºè®°é•¿åº¦ while (p) { p = p-&gt;Next; idx++; } return idx;} // æ—¶é—´æ€§èƒ½O(n)// 2.æŸ¥æ‰¾// ï¼ˆ1ï¼‰æŒ‰åºå·æŸ¥æ‰¾ï¼šFindKthList FindKth(int K, List PtrL){ List p = PtrL; int i = 1; // ä¸€å¼€å§‹pæŒ‡å‘äº†ç¬¬ä¸€ä¸ªå…ƒç´  while (p != NULL &amp;&amp; i &lt; K) { p = p-&gt;Next; i++; } if (i == K) return p; // æ‰¾åˆ°ç¬¬Kä¸ªï¼Œè¿”å›æŒ‡é’ˆ else return NULL; // å¦åˆ™è¿”å›ç©º} // æ—¶é—´æ€§èƒ½O(n)// ï¼ˆ2ï¼‰æŒ‰å€¼æŸ¥æ‰¾List Find(ElementType X, List PtrL){ List p = PtrL; while (p != NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; return p;} // æ—¶é—´æ€§èƒ½O(n)// 3.æ’å…¥ï¼ˆåœ¨ç¬¬i-1(1â‰¤iâ‰¤n+1)ä¸ªç»“ç‚¹åæ’å…¥ä¸€ä¸ªå€¼ä¸ºXçš„æ–°ç»“ç‚¹ï¼‰// ï¼ˆ1ï¼‰æ„é€ ä¸€ä¸ªæ–°çš„ç»“ç‚¹ï¼Œç”¨sæŒ‡å‘ï¼›// ï¼ˆ2ï¼‰å†æ‰¾åˆ°é“¾è¡¨çš„ç¬¬i-1ä¸ªç»“ç‚¹ï¼Œç”¨pæŒ‡å‘ï¼›// ï¼ˆ3ï¼‰ç„¶åä¿®æ”¹æŒ‡é’ˆï¼Œæ’å…¥ç»“ç‚¹ï¼ˆpä¹‹åçš„æ–°ç»“ç‚¹æ—¶sï¼‰List Insert(ElementType X, int i, List PtrL){ List p, s; if (i == 1) // æ–°ç»“ç‚¹æ’å…¥è¡¨å¤´ { s = (List)malloc(sizeof(struct LNode)); // ç”³è¯·å¹¶ä¸”å¡«è£…ç»“ç‚¹ s-&gt;Data = X; s-&gt;Next = PtrL; return s; // è¿”å›æ–°ç»“ç‚¹æŒ‡é’ˆ } p = FindKth(i - 1, PtrL); if (p == NULL) { cout &lt;&lt; \"å‚æ•°é”™è¯¯\" &lt;&lt; endl; return NULL; } else { s = (List)malloc(sizeof(struct LNode)); // ç”³è¯·å¹¶ä¸”å¡«è£… s-&gt;Data = X; s-&gt;Next = p-&gt;Next; // æ–°ç»“ç‚¹æ’å…¥åœ¨ç¬¬i-1ä¸ªç»“ç‚¹çš„åé¢ p-&gt;Next = s; return PtrL; }}// 4.åˆ é™¤ï¼ˆåˆ é™¤é“¾è¡¨çš„ç¬¬iï¼ˆ1â‰¤iâ‰¤nï¼‰ä¸ªä½ç½®ä¸Šçš„ç»“ç‚¹ï¼‰ï¼›// ï¼ˆ1ï¼‰å…ˆæ‰¾åˆ°é“¾è¡¨çš„ç¬¬i-1ä¸ªç»“ç‚¹ï¼Œç”¨pæŒ‡å‘ï¼›// ï¼ˆ2ï¼‰å†ç”¨æŒ‡é’ˆsæŒ‡å‘è¢«åˆ é™¤çš„ç»“ç‚¹ï¼ˆpçš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼‰ï¼›// ï¼ˆ3ï¼‰ç„¶åä¿®æ”¹æŒ‡é’ˆï¼Œåˆ é™¤sæ‰€æŒ‡å‘çš„ç»“ç‚¹// ï¼ˆ4ï¼‰æœ€åé‡Šæ”¾sæ‰€æŒ‡ç»“ç‚¹çš„ç©ºé—´ freeï¼ˆsï¼‰List Delete(int i, List PtrL){ List p, s; if (i == 1) { s = PtrL; if (PtrL) PtrL = PtrL-&gt;Next; else return NULL; free(s); return PtrL; } p = FindKth(i - 1, PtrL); if (p == NULL) { printf(\"ç¬¬%dä¸ªèŠ‚ç‚¹ä¸å­˜åœ¨\", i - 1); return NULL; } else if (p-&gt;Next == NULL) { printf(\"ç¬¬%dä¸ªèŠ‚ç‚¹ä¸å­˜åœ¨\", i); return NULL; } else { s = p-&gt;Next; p-&gt;Next = s-&gt;Next; free(s); return PtrL; }}// æ—¶é—´æ€§èƒ½O(n)int main(){ return 0;}ä½œä¸ºæœ€åŸºç¡€çš„çº¿æ€§ç»“æ„ï¼Œä¹Ÿæ˜¯æœ€é‡è¦çš„ç»“æ„ï¼Œæˆ‘ä»¬ä¸€å®šè¦ç†Ÿç»ƒæŒæ¡ï¼Œäº‰å–è‡ªå·±èƒ½å†™å‡ºæ¥ï¼Œä¸è¦æ±‚ä¸€å­—ä¸å·®çš„å°†æ¨¡æ¿é»˜å†™å‡ºæ¥ï¼Œè¦æ ¹æ®è‡ªå·±çš„ç†è§£æ¥å®ç°å‡ºæ¥ï¼Œå†å®Œæˆè¯¾åä¹ é¢˜ä½œä¸š" }, { "title": "Basic Concepts Of Data Structures's Exercises", "url": "/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%A0%E9%A2%98/", "categories": "Linear Structure", "tags": "Linear Structure Exercises", "date": "2023-01-03 08:17:00 +0000", "snippet": "#æ•°æ®ç»“æ„åŸºæœ¬æ¦‚å¿µæœ¬ç« è¯¾ç¨‹æ¯”è¾ƒç®€å•è€Œä¸”æ¯”è¾ƒæŠ½è±¡â€¦ä¸»è¦æ˜¯æ¯”è¾ƒæŠ½è±¡ï¼Œæˆ‘å°±ç›´æ¥å†™è¯¾åé¢˜ä¸å†™çŸ¥è¯†ç‚¹äº†â€¦â€¦.é¢˜ç›®1å•é“¾è¡¨é€†è½¬æœ¬é“é¢˜ä¸ºå‡½æ•°ä½“ï¼Œæˆ‘ç›´æ¥ç»™å‡ºå‡½æ•°æ¥å£List Reversr (List L){ List p,temp; P-&gt;Next =NULL;//ç»™pçš„æŒ‡é’ˆåŸŸèµ‹ç©ºä½œä¸ºé“¾è¡¨å°¾éƒ¨ while(L){ L-&gt;Next=temp;//å…ˆå¤„ç†ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œ...", "content": "#æ•°æ®ç»“æ„åŸºæœ¬æ¦‚å¿µæœ¬ç« è¯¾ç¨‹æ¯”è¾ƒç®€å•è€Œä¸”æ¯”è¾ƒæŠ½è±¡â€¦ä¸»è¦æ˜¯æ¯”è¾ƒæŠ½è±¡ï¼Œæˆ‘å°±ç›´æ¥å†™è¯¾åé¢˜ä¸å†™çŸ¥è¯†ç‚¹äº†â€¦â€¦.é¢˜ç›®1å•é“¾è¡¨é€†è½¬æœ¬é“é¢˜ä¸ºå‡½æ•°ä½“ï¼Œæˆ‘ç›´æ¥ç»™å‡ºå‡½æ•°æ¥å£List Reversr (List L){ List p,temp; P-&gt;Next =NULL;//ç»™pçš„æŒ‡é’ˆåŸŸèµ‹ç©ºä½œä¸ºé“¾è¡¨å°¾éƒ¨ while(L){ L-&gt;Next=temp;//å…ˆå¤„ç†ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œå°±å…ˆæŠŠåé¢çš„ç»“ç‚¹éƒ½å…ˆå­˜ä¸‹æ¥ L-&gt;Next=p;//å°†ç¬¬ä¸€ä¸ªç»“ç‚¹æŒ‡å‘p p=L;//å†å°†pæŒ‡é’ˆå˜æˆå¤´éƒ¨ L=temp;//æŠŠé¢„å…ˆä¿ç•™çš„é“¾è¡¨å‰©ä½™éƒ¨åˆ†èµ‹å›å» } return p;//è¿›è¡Œå®Œå¾ªç¯ï¼Œpä»æ˜¯æŒ‡é’ˆå¤´éƒ¨ï¼Œè¿”å›på³å¯}åšé“¾è¡¨é¢˜çš„æ—¶å€™å¯ä»¥é€šè¿‡ç”»å›¾æ¥åˆ†æï¼Œå›¾ç”»å‡ºæ¥ï¼Œé—®é¢˜è¿åˆƒè€Œè§£!!ä¸‹é¢ç»™å‡ºæˆ‘çš„å›¾è§£ï¼ˆç”»çš„ä¸å¥½çœ‹å‡‘åˆçœ‹ğŸ˜…ï¼‰é¢˜ç›®äºŒä¸€å…ƒå¤šé¡¹å¼çš„ä¹˜æ³•ä¸åŠ æ³•è¿ç®—" }, { "title": "Basic Concepts Of Data Structures's Exercises", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/", "categories": "Basic Concepts Of Data Structures", "tags": "Data Structure Exercises", "date": "2023-01-03 08:17:00 +0000", "snippet": "#æ•°æ®ç»“æ„åŸºæœ¬æ¦‚å¿µæœ¬ç« è¯¾ç¨‹æ¯”è¾ƒç®€å•è€Œä¸”æ¯”è¾ƒæŠ½è±¡â€¦ä¸»è¦æ˜¯æ¯”è¾ƒæŠ½è±¡ï¼Œæˆ‘å°±ç›´æ¥å†™è¯¾åé¢˜ä¸å†™çŸ¥è¯†ç‚¹äº†â€¦â€¦.é¢˜ç›®1æœ€å¤§å­åˆ—å’Œé—®é¢˜é™ˆè¶Šè€å¸ˆä¸Šè¯¾ç»™å‡ºäº†å››ç§æ–¹æ³•ï¼Œå…¶ä¸­åˆ†æ²»ç®—æ³•æƒ…å†µæ²¡æœ‰ç»™å‡ºä»£ç ï¼Œä¸‹æ–‡ä¸­æˆ‘å·²ç»è¡¥å…¨ã€‚å…ˆç»™å‡ºä¸»å‡½æ•°int main(){ int n; int a[100000 + 5]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i+...", "content": "#æ•°æ®ç»“æ„åŸºæœ¬æ¦‚å¿µæœ¬ç« è¯¾ç¨‹æ¯”è¾ƒç®€å•è€Œä¸”æ¯”è¾ƒæŠ½è±¡â€¦ä¸»è¦æ˜¯æ¯”è¾ƒæŠ½è±¡ï¼Œæˆ‘å°±ç›´æ¥å†™è¯¾åé¢˜ä¸å†™çŸ¥è¯†ç‚¹äº†â€¦â€¦.é¢˜ç›®1æœ€å¤§å­åˆ—å’Œé—®é¢˜é™ˆè¶Šè€å¸ˆä¸Šè¯¾ç»™å‡ºäº†å››ç§æ–¹æ³•ï¼Œå…¶ä¸­åˆ†æ²»ç®—æ³•æƒ…å†µæ²¡æœ‰ç»™å‡ºä»£ç ï¼Œä¸‹æ–‡ä¸­æˆ‘å·²ç»è¡¥å…¨ã€‚å…ˆç»™å‡ºä¸»å‡½æ•°int main(){ int n; int a[100000 + 5]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; auto res = MaxSubseqSum1(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum2(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum3(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum4(n, a); cout &lt;&lt; res &lt;&lt; endl; res = MaxSubseqSum5(n, a); cout &lt;&lt; res &lt;&lt; endl; return 0;}ç®—æ³•ä¸€æœ€ç›´æ¥ä¹Ÿæ˜¯æœ€ç›´è§‚çš„æƒ³æ³•ï¼Œä¸€ä¸ªå¾ªç¯æ§åˆ¶å­åˆ—çš„å°¾éƒ¨ï¼Œå†…åµŒä¸€ä¸ªå¾ªç¯æ§åˆ¶å­åˆ—çš„å¤´éƒ¨ï¼Œå†å†…åµŒä¸€ä¸ªå¾ªç¯æ¥æ±‚è§£é¦–éƒ¨åˆ°å°¾éƒ¨é—´å­åˆ—å’Œï¼Œæ¯æ¬¡æ±‚è§£å®Œå’Œæ›´æ–°æœ€å¤§å€¼ã€‚int MaxSubseqSum1(int n, int *a){ int ThisSum, max = 0; int i, j, k; for (i = 0; i &lt; n; i++) // iæ˜¯å­åˆ—å·¦ç«¯ { for (j = i; j &lt; n; j++) // jæ˜¯å­åˆ—å³ç«¯ { ThisSum = 0; // ThisSumæ˜¯ä»a[i]åˆ°a[j]çš„å’Œ for (k = i; k &lt;= j; k++) ThisSum += a[k]; if (ThisSum &gt; max) max = ThisSum; // å¦‚æœå¤§ï¼Œå°±æ›´æ–°å­åˆ— } // jå¾ªç¯ç»“æŸ } // iå¾ªç¯ç»“æŸ return max;}æœ€å¥½ç†è§£ï¼Œæ—¶é—´å¤æ‚åº¦ä¹Ÿæœ€å¤§T(N)=O(N^3)ç®—æ³•äºŒè€ƒè™‘ä¼˜åŒ–ç®—æ³•ä¸€ï¼Œè§‚å¯Ÿå‘ç°æ¯æ¬¡è®¡ç®—ä¹‹åçš„å­åˆ—å’Œå‰é¢çš„å­åˆ—éƒ½éœ€è¦é‡æ–°è®¡ç®—ï¼ˆæ¯”å¦‚è®¡ç®— Sum(n+1)éœ€è¦é‡æ–°è®¡ç®— Sum(n)ï¼‰ï¼Œé‚£æˆ‘ä»¬å¯ä»¥è¿™æ ·ä¼˜åŒ–ï¼Œæƒ³åŠæ³•èƒ½ä¸èƒ½å°†æ¯æ¬¡è®¡ç®—çš„ç»“æœä¿å­˜ä¸€ä¸‹ï¼Œå³ä¸€ä¸ªå¾ªç¯æ§åˆ¶å­åˆ—çš„é¦–éƒ¨ï¼Œå†…åµŒä¸€ä¸ªå¾ªç¯ï¼Œæ—¢æ§åˆ¶å­åˆ—çš„å°¾éƒ¨ï¼Œä¹Ÿè¡¨ç¤ºè¯¥æ®µå­åˆ—å’Œï¼Œå åŠ ä¸€æ¬¡æ›´æ–°ä¸€æ¬¡æœ€å¤§å€¼ã€‚int MaxSubseqSum2(int n, int *a){ int ThisSum, max = 0; int i, j; for (i = 0; i &lt; n; i++) // iæ˜¯å­åˆ—å·¦ç«¯ { ThisSum = 0; // ThisSumæ˜¯ä»a[i]åˆ°a[j]çš„å’Œ for (j = i; j &lt;= n; j++) // jæ˜¯å­åˆ—å³ç«¯ { ThisSum += a[j]; // å¯¹äºç›¸åŒçš„iä¸åŒçš„jï¼Œä¸»è¦åœ¨j-1æ¬¡å¾ªç¯çš„åŸºç¡€ä¸Šç´¯åŠ 1é¡¹å³å¯ if (ThisSum &gt; max) max = ThisSum; // å¦‚æœå¤§ï¼Œå°±æ›´æ–°å­åˆ— } // jå¾ªç¯ç»“æŸ } // iå¾ªç¯ç»“æŸ return max;} // æŠŠä¹‹å‰æ§åˆ¶å°¾éƒ¨çš„å¾ªç¯å’Œæ±‚è§£å­åˆ—å’Œçš„å¾ªç¯èåˆäº†ï¼ŒT(N)=O(N^2)ç®—æ³•ä¸‰ç®—æ³•ä¸‰å’Œç®—æ³•äºŒç±»ä¼¼ï¼Œä¸è¿‡ç®—æ³•äºŒæ˜¯æ§åˆ¶é¦–éƒ¨ï¼Œé€æ¸ç´¯åŠ ï¼Œç®—æ³•ä¸‰æ˜¯æ§åˆ¶å°¾éƒ¨ï¼Œé€æ¸å‡å€¼ã€‚ä»é¦–éƒ¨å‡ºå‘å¯ä»¥è‡ªç„¶çš„ç”¨ä¸€ä¸ªæ•°ä¿å­˜æ•´æ®µå­åˆ—å’Œï¼Œè€Œä»å°¾éƒ¨å‡ºå‘åˆ™éœ€è¦é¢å¤–æ•°ç»„ç©ºé—´æ¥ä¿å­˜å­åˆ—å’Œï¼Œé¢å¤–æ•°ç»„ç©ºé—´é¦–å…ˆä¿å­˜å…¶å‰ n ä¸ªæ•°ä¹‹å’Œï¼Œç„¶åæ¯æ¬¡å‡å»å½“å‰å€¼å½¢æˆå­åˆ—å’Œã€‚int MaxSubseqSum3(int n, int a[]) // æ–¹æ³•ä¸‰ï¼šç¡®å®šå­åˆ—çš„ç»“å°¾ï¼Œé€ä¸ªå‡å»å­åˆ—å‰çš„æ•°ï¼Œæ—¶é—´å¤æ‚åº¦ O(n^2){ int sum[100000 + 5]; int max = 0; sum[0] = a[0]; for (int i = 1; i &lt; n; i++) // é¢„å¤„ç†ä¿å­˜å‰ n ä¸ªæ•°ä¹‹å’Œ sum[i] = sum[i - 1] + a[i]; for (int i = 0; i &lt; n; i++) // æ§åˆ¶å°¾éƒ¨ { int tmpSum = sum[i]; for (int j = 0; j &lt;= i; j++) // æ§åˆ¶é¦–éƒ¨ï¼Œæ¯ä¸€æ¬¡å‡å»å½“å‰å€¼å³é¦–å°¾å­åˆ—å’Œ { if (max &lt; tmpSum) max = tmpSum; tmpSum -= a[j]; } } return max;}ç®—æ³•å››é€’å½’åˆ†æˆä¸¤ä»½ï¼Œåˆ†åˆ«æ±‚æ¯ä¸ªåˆ†å‰²åæœ€å¤§å­åˆ—å’Œï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n*logn)/* è¿”å›ä¸‰è€…ä¸­æœ€å¤§å€¼*/int Max3(int A, int B, int C){ return (A &gt; B) ? ((A &gt; C) ? A : C) : ((B &gt; C) ? B : C);}/* åˆ†æ²»*/int DivideAndConquer(int a[], int left, int right){ /*é€’å½’ç»“æŸæ¡ä»¶ï¼šå­åˆ—åªæœ‰ä¸€ä¸ªæ•°å­—*/ // å½“è¯¥æ•°ä¸ºæ­£æ•°æ—¶ï¼Œæœ€å¤§å­åˆ—å’Œä¸ºå…¶æœ¬èº« // å½“è¯¥æ•°ä¸ºè´Ÿæ•°æ—¶ï¼Œæœ€å¤§å­åˆ—å’Œä¸º 0 if (left == right) { if (0 &lt; a[left]) return a[left]; return 0; } /* åˆ†åˆ«é€’å½’æ‰¾åˆ°å·¦å³æœ€å¤§å­åˆ—å’Œ*/ int center = (left + right) / 2; int MaxLeftSum = DivideAndConquer(a, left, center); int MaxRightSum = DivideAndConquer(a, center + 1, right); /* å†åˆ†åˆ«æ‰¾å·¦å³è·¨ç•Œæœ€å¤§å­åˆ—å’Œ*/ int MaxLeftBorderSum = 0; int LeftBorderSum = 0; for (int i = center; i &gt;= left; i--) { // åº”è¯¥ä»è¾¹ç•Œå‡ºå‘å‘å·¦è¾¹æ‰¾ LeftBorderSum += a[i]; if (MaxLeftBorderSum &lt; LeftBorderSum) MaxLeftBorderSum = LeftBorderSum; } int MaXRightBorderSum = 0; int RightBorderSum = 0; for (int i = center + 1; i &lt;= right; i++) { // ä»è¾¹ç•Œå‡ºå‘å‘å³è¾¹æ‰¾ RightBorderSum += a[i]; if (MaXRightBorderSum &lt; RightBorderSum) MaXRightBorderSum = RightBorderSum; } // æœ€åè¿”å›åˆ†è§£çš„å·¦è¾¹æœ€å¤§å­åˆ—å’Œï¼Œå³è¾¹æœ€å¤§å­åˆ—å’Œï¼Œå’Œè·¨ç•Œæœ€å¤§å­åˆ—å’Œä¸‰è€…ä¸­æœ€å¤§çš„æ•° return Max3(MaxLeftSum, MaxRightSum, MaXRightBorderSum + MaxLeftBorderSum);}int MaxSubseqSum4(int n, int a[]){ return DivideAndConquer(a, 0, n - 1);}ç®—æ³•äº”â€œè´ªå¿ƒæ³•â€ï¼Œå³ä¸ä»æ•´ä½“æœ€ä¼˜ä¸ŠåŠ ä»¥è€ƒè™‘ï¼Œåªåšå‡ºæŸç§æ„ä¹‰ä¸Šçš„å±€éƒ¨æœ€ä¼˜è§£ã€‚å…¶å®æœ€å¤§å­åˆ—å’Œä¸å®ƒçš„é¦–éƒ¨å’Œå°¾éƒ¨éƒ½æ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬åªå…³å¿ƒå®ƒå½“å‰çš„å¤§å°ã€‚å½“ä¸´æ—¶å’ŒåŠ ä¸Šå½“å‰å€¼ä¸ºè´Ÿæ—¶ï¼Œå®ƒå¯¹ä¹‹åå­åˆ—å’Œè‚¯å®šæ²¡æœ‰å¸®åŠ©ï¼ˆç”šè‡³åªä¼šè®©ä¹‹åçš„å’Œæ›´å°ï¼ï¼‰ï¼Œæˆ‘ä»¬æŠ›å¼ƒè¿™æ®µä¸´æ—¶å’Œå°†å®ƒç½®0ã€‚int MaxSubseqSum5(int n, int a[]) // æ–¹æ³•äº”ï¼šç›´æ¥ç´¯åŠ ï¼Œå¦‚æœç´¯åŠ åˆ°å½“å‰çš„å’Œä¸ºè´Ÿæ•°ï¼Œç½®å½“å‰å€¼æˆ–0ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(N){ int max = 0; int tmpSum = 0; for (int i = 0; i &lt; n; i++) { tmpSum += a[i]; if (tmpSum &lt; 0) { tmpSum = 0; } else if (max &lt; tmpSum) { max = tmpSum; } } return max;}æ—¶é—´å¤æ‚åº¦æœ€å¥½ï¼Œæ˜¯çº¿æ€§çš„ï¼Œä¸ºO(n)ã€‚veryæ¨èï¼Œå¾ˆå¥½ç†è§£çš„é¢˜ç›®2ï¼šæœ€å¤§å­åˆ—å’ŒåŠ å¼ºç‰ˆMaximum Subsequence Suméƒ¨åˆ†é¢˜å¹²ï¼ˆé‡ç‚¹ï¼‰Output Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.ç®€å•æ¥è¯´å°±æ˜¯æ³¨æ„ä»¥ä¸‹å‡ ä¸ªç‚¹ï¼ˆå‘ï¼‰ï¼š1.å¦‚æœå…¨éƒ½æ˜¯è´Ÿæ•°ï¼Œåˆ™è¾“å‡º[0 ç¬¬ä¸€ä¸ªæ•° æœ€åä¸€ä¸ªæ•°]2.å¦‚æœåŸåºåˆ—ä¸­é™¤äº†0å°±æ˜¯è´Ÿæ•°ï¼Œå¦‚ï¼šâ€˜0 -3 -6â€™ï¼Œåˆ™è¾“å‡ºã€0 0 0ã€‘ï¼ˆè¿™ä¸ªæ—¶å€™sumMaxè‚¯å®šæ˜¯0ï¼‰#include &lt;iostream&gt;using namespace std;int s[100010];int main (int argc,char const *argv[]) {\tint n,cnt=0,max=-1,sum=0;\tcin &gt;&gt; n;\tint l=0,r=n-1,tl=0;\tfor(int i=0; i&lt;n; i++) {\t\tcin &gt;&gt; s[i];\t\tif(s[i]&lt;0){\t\t\tcnt++; //ç”¨äºçœ‹æœ‰æ²¡æœ‰è´Ÿæ•°ï¼Œå¦‚æœcnt==nåˆ™éƒ½æ˜¯è´Ÿæ•°\t\t}\t}\tfor(int i=0;i&lt;n;i++){\t\tsum+=s[i];\t\tif(sum&lt;0){\t\t\tsum=0;\t\t\ttl=i+1; //tlä¸ºè¢«èˆå¼ƒçš„ä¸‹ä¸€é¡¹\t\t}\t\telse if(sum&gt;max){\t\t\tmax=sum;\t\t\tl=tl;\t\t\tr=i;\t\t}\t}\tif(cnt==n){\t\tcout &lt;&lt; \"0 \"&lt;&lt; s[0] &lt;&lt; \" \" &lt;&lt; s[n-1];\t}\telse{\t\tcout &lt;&lt; max &lt;&lt; \" \" &lt;&lt; s[l] &lt;&lt; \" \" &lt;&lt; s[r];\t} \treturn 0;}" } ]
